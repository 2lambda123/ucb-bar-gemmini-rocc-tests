diff --git a/include/gemmini.h b/include/gemmini.h
index e805935..aa6f6eb 100644
--- a/include/gemmini.h
+++ b/include/gemmini.h
@@ -19,6 +19,9 @@
 // Accelerator interface
 #include "rocc-software/src/xcustom.h"
 
+// Counter Definition
+#include "include/gemmini_counter.h"
+
 #define k_CONFIG 0
 #define k_MVIN2 1
 #define k_MVIN 2
@@ -37,6 +40,8 @@
 
 #define k_MVIN3 14
 
+#define k_COUNTER 126
+
 #define k_LOOP_CONV_WS 15
 #define k_LOOP_CONV_WS_CONFIG_1 16
 #define k_LOOP_CONV_WS_CONFIG_2 17
@@ -138,6 +143,8 @@ static scale_t_bits scale_t_to_scale_t_bits(scale_t x) {
     un.f = x;
     return un.b;
 }
+#else
+#define scale_t_to_scale_t_bits(x) 0
 #endif
 
 #ifdef HAS_MVIN_ACC_SCALE
@@ -231,24 +238,29 @@ static acc_scale_t_bits acc_scale_t_to_acc_scale_t_bits(acc_scale_t x) {
   gemmini_preload(GARBAGE_ADDR, C)
 
 // config
-#define gemmini_extended3_config_ex(dataflow, act, sys_shift, acc_scale, relu6_shift, C_stride, A_stride, A_transpose, B_transpose, ocol, row_turn, kdim, stride, channel, row_left, kdim2, weight_double_bank, weight_triple_bank, set_only_strides) \
+#define gemmini_extended3_config_ex(dataflow, sys_act, sys_shift, sys_acc_scale, relu6_shift, C_stride, A_stride, A_transpose, B_transpose, ocol, row_turn, kdim, stride, channel, row_left, kdim2, weight_double_bank, weight_triple_bank, set_only_strides) \
   { \
-    ROCC_INSTRUCTION_RS1_RS2(XCUSTOM_ACC, ((uint64_t)acc_scale_t_to_acc_scale_t_bits((acc_scale_t)acc_scale) << 32) | ((uint64_t)(A_stride) << 16) | (B_transpose << 9) | (A_transpose << 8) | ((set_only_strides) << 7) | ((act) << 3) | ((dataflow) << 2) | CONFIG_EX, ((uint64_t)(C_stride) << 48) | ((uint64_t)(relu6_shift) << 32) | (sys_shift), k_CONFIG); \
+    ROCC_INSTRUCTION_RS1_RS2(XCUSTOM_ACC, ((uint64_t)acc_scale_t_to_acc_scale_t_bits((acc_scale_t)sys_acc_scale) << 32) | ((uint64_t)(A_stride) << 16) | (B_transpose << 9) | (A_transpose << 8) | ((set_only_strides) << 7) | ((sys_act) << 3) | ((dataflow) << 2) | CONFIG_EX, ((uint64_t)(C_stride) << 48) | ((uint64_t)(relu6_shift) << 32) | (sys_shift), k_CONFIG); \
     \
     ROCC_INSTRUCTION_RS1_RS2(XCUSTOM_ACC, ((uint64_t)(weight_triple_bank) << 59) | ((uint64_t)(weight_double_bank) << 58) | ((uint64_t)(row_left) << 54) | ((uint64_t)(row_turn) << 42) | CONFIG_IM2COL, ((uint64_t)ocol << 56) | ((uint64_t)kdim2 << 48) | ((uint64_t)kdim << 44) | ((uint64_t)channel << 23) | ((uint64_t)stride << 20), k_CONFIG) \
   }
 
-#define gemmini_extended2_config_ex(dataflow, act, sys_shift, acc_scale, relu6_shift, A_stride, A_transpose, B_transpose, ocol, row_turn, kdim, stride, channel, row_left, kdim2, weight_double_bank, weight_triple_bank) \
-  gemmini_extended3_config_ex(dataflow, act, sys_shift, acc_scale, relu6_shift, 1, A_stride, A_transpose, B_transpose, 0, 0, 0, 0, 0, 0, 0, 0, 0, false)
+#define gemmini_extended2_config_ex(dataflow, sys_act, sys_shift, relu6_shift, A_stride, A_transpose, B_transpose, ocol, row_turn, kdim, stride, channel, row_left, kdim2, weight_double_bank, weight_triple_bank) \
+  gemmini_extended3_config_ex(dataflow, sys_act, sys_shift, ACC_SCALE_IDENTITY, relu6_shift, 1, A_stride, A_transpose, B_transpose, 0, 0, 0, 0, 0, 0, 0, 0, 0, false)
+
+#define gemmini_extended_config_ex(dataflow, sys_act, sys_shift, relu6_shift, A_stride, A_transpose, B_transpose) \
+  gemmini_extended2_config_ex(dataflow, sys_act, sys_shift, relu6_shift, A_stride, A_transpose, B_transpose, 0, 0, 0, 0, 0, 0, 0, 0, 0)
 
-#define gemmini_extended_config_ex(dataflow, act, sys_shift, acc_scale, relu6_shift, A_stride, A_transpose, B_transpose) \
-  gemmini_extended2_config_ex(dataflow, act, sys_shift, acc_scale, relu6_shift, A_stride, A_transpose, B_transpose, 0, 0, 0, 0, 0, 0, 0, 0, 0)
+#define gemmini_config_ex(dataflow, sys_act, sys_shift, relu6_shift) \
+    gemmini_extended_config_ex(dataflow, sys_act, sys_shift, relu6_shift, 1, 0, 0)
 
-#define gemmini_config_ex(dataflow, act, sys_shift, acc_scale, relu6_shift) \
-    gemmini_extended_config_ex(dataflow, act, sys_shift, acc_scale, relu6_shift, 1, 0, 0)
+// Note: The "pixel_repeats" parameter below is still experimental, andthere is
+// a high chance that it will be removed in future releases.
+#define gemmini_extended5_config_ld(stride, scale, shrunk, block_mvin_stride, pixel_repeats, id) \
+  ROCC_INSTRUCTION_RS1_RS2(XCUSTOM_ACC, ((uint64_t)(scale_t_to_scale_t_bits(scale)) << 32) | ((uint64_t)(block_mvin_stride) << 16) | ((uint64_t)(pixel_repeats) << 8) | ((id) << 3) | ((shrunk) << 2) | CONFIG_LD, stride, k_CONFIG)
 
 #define gemmini_extended4_config_ld(stride, scale, shrunk, block_mvin_stride, id) \
-  ROCC_INSTRUCTION_RS1_RS2(XCUSTOM_ACC, ((uint64_t)(scale_t_to_scale_t_bits(scale)) << 32) | ((uint64_t)(block_mvin_stride) << 16) | ((id) << 3) | ((shrunk) << 2) | CONFIG_LD, stride, k_CONFIG)
+  gemmini_extended5_config_ld(stride, scale, shrunk, block_mvin_stride, 1, id) \
 
 #define gemmini_extended3_config_ld(stride, scale, shrunk, id) \
   gemmini_extended4_config_ld(stride, scale, shrunk, DIM, id)
@@ -262,11 +274,14 @@ static acc_scale_t_bits acc_scale_t_to_acc_scale_t_bits(acc_scale_t x) {
 #define gemmini_config_ld(stride) \
   gemmini_extended_config_ld(stride, MVIN_SCALE_IDENTITY)
 
-#define gemmini_extended_config_st(stride, pool_stride, pool_size, pool_out_dim, porows, pocols, orows, ocols, upad, lpad) \
-  ROCC_INSTRUCTION_RS1_RS2(XCUSTOM_ACC, ((uint64_t)(ocols) << 56) | ((uint64_t)(orows) << 48) | ((uint64_t)(pocols) << 40) | ((uint64_t)(porows) << 32) | ((uint64_t)(pool_out_dim) << 24) | ((uint64_t)(lpad) << 10) | ((uint64_t)(upad) << 8) | ((uint64_t)(pool_size) << 6) | ((uint64_t)(pool_stride) << 4) | CONFIG_ST, stride, k_CONFIG)
+#define gemmini_extended2_config_st(stride, acc_act, acc_scale, pool_stride, pool_size, pool_out_dim, porows, pocols, orows, ocols, upad, lpad) \
+  ROCC_INSTRUCTION_RS1_RS2(XCUSTOM_ACC, ((uint64_t)(ocols) << 56) | ((uint64_t)(orows) << 48) | ((uint64_t)(pocols) << 40) | ((uint64_t)(porows) << 32) | ((uint64_t)(pool_out_dim) << 24) | ((uint64_t)(lpad) << 10) | ((uint64_t)(upad) << 8) | ((uint64_t)(pool_size) << 6) | ((uint64_t)(pool_stride) << 4) | ((acc_act) << 2) | CONFIG_ST, ((uint64_t)acc_scale_t_to_acc_scale_t_bits((acc_scale_t)acc_scale) << 32) | ((uint32_t)stride), k_CONFIG)
+
+#define gemmini_extended_config_st(stride, acc_act, acc_scale) \
+    gemmini_extended2_config_st(stride, acc_act, acc_scale, 0, 0, 0, 0, 0, 0, 0, 0, 0)
 
 #define gemmini_config_st(stride) \
-    gemmini_extended_config_st(stride, 0, 0, 0, 0, 0, 0, 0, 0, 0)
+    gemmini_extended_config_st(stride, NO_ACTIVATION, ACC_SCALE_IDENTITY)
 
 // flush
 #define gemmini_flush(skip) \
@@ -275,6 +290,54 @@ static acc_scale_t_bits acc_scale_t_to_acc_scale_t_bits(acc_scale_t x) {
 // fence
 #define gemmini_fence() asm volatile("fence")
 
+// Counter access
+#define gemmini_counter_access(rd, config_reg) \
+  { \
+    uint32_t _placeholder; \
+    ROCC_INSTRUCTION(XCUSTOM_ACC, rd, config_reg, _placeholder, k_COUNTER) \
+  }
+
+// Read counter
+static uint32_t counter_read(size_t index) {
+  uint32_t config_reg = (index & 0x7) << 4;
+  uint32_t res;
+  gemmini_counter_access(res, config_reg);
+  return res;
+}
+
+// Configure counter to take a new signal
+static void counter_configure(size_t index, size_t counter_code) {
+  int non_incremental = counter_code > INCREMENTAL_COUNTERS;
+  if (non_incremental) {
+    counter_code -= INCREMENTAL_COUNTERS;
+  }
+
+  uint32_t config_reg = (index & 0x7) << 4 | 0x8 | (counter_code & 0x3f) << 12 | non_incremental << 31;
+  uint32_t placeholder;
+  gemmini_counter_access(placeholder, config_reg);
+}
+
+// Take a snapshot
+static void counter_snapshot_take() {
+  uint32_t config_reg = 0x4;
+  uint32_t placeholder;
+  gemmini_counter_access(placeholder, config_reg);
+}
+
+// Counter snapshot reset
+static void counter_snapshot_reset() {
+  uint32_t config_reg = 0x2;
+  uint32_t placeholder;
+  gemmini_counter_access(placeholder, config_reg);
+}
+
+// Counter module reset
+static void counter_reset() {
+  uint32_t config_reg = 0x1;
+  uint32_t placeholder;
+  gemmini_counter_access(placeholder, config_reg);
+}
+
 // weight-stationary matmul loop
 #define gemmini_loop_ws(I, J, K, pad_I, pad_J, pad_K, A, B, D, C, A_stride, B_stride, D_stride, C_stride, A_transpose, B_transpose, full_C, low_D, ex_accumulate, weightA) \
   { \
@@ -286,8 +349,8 @@ static acc_scale_t_bits acc_scale_t_to_acc_scale_t_bits(acc_scale_t x) {
     ROCC_INSTRUCTION_RS1_RS2(XCUSTOM_ACC, ((uint64_t)(weightA) << 8) | ((low_D) << 2) | ((full_C) << 1) | (ex_accumulate), ((B_transpose) << 1) | (A_transpose), k_LOOP_WS) \
   }
 
-// weight-stationary matmul loop
-#define gemmini_loop_conv_ws(batch_size, in_dim, in_channels, out_channels, out_dim, pool_out_dim, stride, padding, kernel_dim, kernel_dilation, pool_size, pool_stride, pool_padding, batches, porows, pocols, pochs, krows, kcols, kchs, lpad, rpad, upad, dpad, plpad, prpad, pupad, pdpad, orows, ocols, weights, output, bias, input, no_bias, no_pool, downsample, wrot180, input_dilated, trans_output_1203, trans_weight_1203, trans_weight_0132, trans_input_3120) \
+// weight-stationary conv loop
+#define gemmini_loop_conv_ws(batch_size, in_dim, in_channels, out_channels, out_dim, pool_out_dim, stride, padding, kernel_dim, kernel_dilation, pool_size, pool_stride, pool_padding, batches, porows, pocols, pochs, krows, kcols, kchs, lpad, rpad, upad, dpad, plpad, prpad, pupad, pdpad, orows, ocols, weights, output, bias, input, no_bias, no_pool, downsample, wrot180, input_dilated, activation, trans_output_1203, trans_weight_1203, trans_weight_0132, trans_input_3120, max_pixels_per_row) \
   { \
     ROCC_INSTRUCTION_RS1_RS2(XCUSTOM_ACC, ((uint64_t)(out_channels) << 48) | ((uint64_t)(in_channels) << 32) | ((uint64_t)(in_dim) << 16) | (uint64_t)(batch_size), \
       ((uint64_t)(padding) << 48) | ((uint64_t)(stride) << 32) | ((uint64_t)(pool_out_dim) << 16) | (uint64_t)(out_dim), k_LOOP_CONV_WS_CONFIG_1) \
@@ -301,8 +364,9 @@ static acc_scale_t_bits acc_scale_t_to_acc_scale_t_bits(acc_scale_t x) {
       output, k_LOOP_CONV_WS_CONFIG_5) \
     ROCC_INSTRUCTION_RS1_RS2(XCUSTOM_ACC, bias, \
       input, k_LOOP_CONV_WS_CONFIG_6) \
-    ROCC_INSTRUCTION_RS1_RS2(XCUSTOM_ACC, ((trans_input_3120) << 5) | ((trans_weight_0132) << 4) | ((trans_weight_1203) << 3) | ((trans_output_1203) << 2) | ((wrot180) << 1) | (no_bias), \
-      ((input_dilated) << 2) | ((downsample) << 1) | (no_pool), k_LOOP_CONV_WS) \
+    ROCC_INSTRUCTION_RS1_RS2(XCUSTOM_ACC, ((uint64_t)(max_pixels_per_row) << 8) | ((trans_input_3120) << 5) | ((trans_weight_0132) << 4) | ((trans_weight_1203) << 3) | ((trans_output_1203) << 2) | ((wrot180) << 1) | (no_bias), \
+      ((activation) << 3)| ((input_dilated) << 2) | ((downsample) << 1) | (no_pool), \
+      k_LOOP_CONV_WS) \
   }
 
 // Tiling functions
@@ -426,6 +490,7 @@ static void sp_tiled_matmul_os(const elem_t * A, const elem_t * B, const void *
   }
 }
 
+
 static void sp_tiled_matmul_ws(const elem_t * A, const elem_t * B,
         const void * D, void * C,
         scale_t A_scale_factor, scale_t B_scale_factor, scale_acc_t D_scale_factor,
@@ -570,6 +635,7 @@ static void sp_tiled_matmul_ws(const elem_t * A, const elem_t * B,
     weightA);
 }
 
+
 static void tiled_matmul_outer(size_t dim_I, size_t dim_J, size_t dim_K,
         const elem_t* A, const elem_t* B,
         const void * D, void * C,
@@ -611,8 +677,8 @@ static void tiled_matmul_outer(size_t dim_I, size_t dim_J, size_t dim_K,
   const size_t sizeof_D = low_D ? sizeof(elem_t) : sizeof(acc_t) ;
   const size_t sizeof_C = full_C ? sizeof(acc_t) : sizeof(elem_t);
 
-  gemmini_extended_config_ex(dataflow, act, 0, scale, relu6_shift, 1, a_transpose, b_transpose);
-  gemmini_config_st(stride_C * sizeof_C);
+  gemmini_extended_config_ex(dataflow, act, 0, relu6_shift, 1, a_transpose, b_transpose);
+  gemmini_extended_config_st(stride_C * sizeof_C, act, scale);
   gemmini_extended3_config_ld(stride_A * sizeof(elem_t), A_scale_factor, false, 0);
   gemmini_extended3_config_ld(stride_B * sizeof(elem_t), B_scale_factor, false, 1)
   gemmini_extended3_config_ld(repeating_bias ? 0 : (stride_D * sizeof_D), D_scale_factor, low_D, 2);
@@ -675,6 +741,7 @@ static void tiled_matmul_outer(size_t dim_I, size_t dim_J, size_t dim_K,
   gemmini_fence();
 }
 
+
 static elem_t scale_and_sat(acc_t x, int act, acc_scale_t scale, size_t relu6_shift) {
   // Scale value down and round it
   x = ACC_SCALE(x, scale);
@@ -943,10 +1010,12 @@ static void tiled_matmul(size_t dim_I, size_t dim_J, size_t dim_K,
   }
 }
 
+
 static size_t tiled_matmul_total_spad_rows(size_t I, size_t J, size_t K) {
   return (I * K + K * J) * DIM;
 }
 
+
 static size_t tiled_matmul_total_acc_rows(size_t I, size_t J) {
   return (I * J) * DIM;
 }
@@ -1060,7 +1129,8 @@ static void tiled_matmul_auto(size_t dim_I, size_t dim_J, size_t dim_K,
 #undef max_tile_k
 }
 
-static void sp_tiled_conv_A_stride(
+
+static void sp_tiled_conv(
         int batch_size, int in_dim, int in_channels,
         int out_channels, int out_dim, int pool_out_dim,
 
@@ -1080,6 +1150,8 @@ static void sp_tiled_conv_A_stride(
         elem_t * output,
         const acc_t * bias,
 
+        int act, acc_scale_t scale,
+
         bool wrot180, bool trans_output_1203, bool trans_input_3120,
         bool trans_weight_1203, bool trans_weight_0132,
 
@@ -1109,6 +1181,17 @@ static void sp_tiled_conv_A_stride(
     icols = icols_unpadded + UNDILATED(lpad) + UNDILATED(rpad);
   }
 
+#ifdef HAS_FIRST_LAYER_OPTIMIZATIONS
+  const bool transposed = trans_output_1203 || trans_input_3120 ||
+      trans_weight_1203 || trans_weight_0132;
+  int max_pixels_per_row = transposed || wrot180 || downsample ||
+      input_dilated || kernel_dilation > 1 ||
+      ichs > DIM ? 1 : DIM/ichs;
+  if (max_pixels_per_row > kcols) max_pixels_per_row = kcols;
+#else
+  const int max_pixels_per_row = 1;
+#endif
+
   // Calculate spad address offsets
   const int out_channels_per_bank = ochs / DIM + (ochs % DIM != 0);
   const int in_channels_per_bank = kchs / DIM + (kchs % DIM != 0);
@@ -1132,7 +1215,7 @@ static void sp_tiled_conv_A_stride(
     C_sp_addr_row = (C_sp_addr_row + ACC_ROWS / 2) % ACC_ROWS;
   }
 
-  gemmini_loop_conv_ws(batch_size, in_dim, in_channels, out_channels, out_dim, pool_out_dim, stride, padding, kernel_dim, kernel_dilation, pool_size, pool_stride, pool_padding, batches, porows, pocols, pochs, krows, kcols, kchs, lpad, rpad, upad, dpad, plpad, prpad, pupad, pdpad, orows, ocols, weights, output, bias, input, no_bias, no_pool, downsample, wrot180, input_dilated, trans_output_1203, trans_weight_1203, trans_weight_0132, trans_input_3120);
+  gemmini_loop_conv_ws(batch_size, in_dim, in_channels, out_channels, out_dim, pool_out_dim, stride, padding, kernel_dim, kernel_dilation, pool_size, pool_stride, pool_padding, batches, porows, pocols, pochs, krows, kcols, kchs, lpad, rpad, upad, dpad, plpad, prpad, pupad, pdpad, orows, ocols, weights, output, bias, input, no_bias, no_pool, downsample, wrot180, input_dilated, act, trans_output_1203, trans_weight_1203, trans_weight_0132, trans_input_3120, max_pixels_per_row);
 
   /*
   // mvin bias
@@ -1180,7 +1263,7 @@ static void sp_tiled_conv_A_stride(
       ichs * (irows >> downsample) * (icols >> downsample) :
       batches * (irows >> downsample) * (icols >> downsample);
 
-    gemmini_extended4_config_ld(dram_stride << downsample, MVIN_SCALE_IDENTITY, false, spad_stride, 0);
+    gemmini_extended5_config_ld(dram_stride << downsample, MVIN_SCALE_IDENTITY, false, spad_stride, max_pixels_per_row, 0);
 
     const int b_it = trans_input_3120 ? max_chs_per_mvin : 1;
     const int ich_it = trans_input_3120 ? 1 : max_chs_per_mvin;
@@ -1295,12 +1378,12 @@ static void sp_tiled_conv_A_stride(
     const int ocol_it = trans_input_3120 ? 1 : (DIM << input_dilated);
 
     if (trans_input_3120) {
-      gemmini_extended3_config_ex(0, 0, 0, 0, 0, orows * ocols, irows * icols, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, true);
+      gemmini_extended3_config_ex(0, 0, 0, 0, 0, 0, orows * ocols, irows * icols, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, true);
     }
 
     for (int och = 0; och < ochs; och += DIM) {
       for (int krow = 0; krow < krows; krow++) {
-        for (int kcol = 0; kcol < kcols; kcol++) {
+        for (int kcol = 0; kcol < kcols; kcol += max_pixels_per_row) {
           for (int kch = 0; kch < kchs; kch += DIM) {
             bool new_weights = true;
 
@@ -1326,6 +1409,9 @@ static void sp_tiled_conv_A_stride(
                     icol = (icol + 1) / 2;
                   }
 
+                  const int pixels = kcols - kcol > max_pixels_per_row ?
+                    max_pixels_per_row : kcols - kcol;
+
                   const uint32_t C_sp_addr = C_sp_addr_start + (och / DIM) * batches * orows * ocols + b * orows * ocols + orow * ocols + ocol;
 
                   // Over here, construct a new matrix
@@ -1341,7 +1427,7 @@ static void sp_tiled_conv_A_stride(
 
                   int I = UNDILATED(ocols - ocol > (DIM << input_dilated) ? (DIM << input_dilated) : ocols - ocol);
                   const int J = ochs - och > DIM ? DIM : ochs - och;
-                  const int K = kchs - kch > DIM ? DIM : kchs - kch;
+                  const int K = pixels * (kchs - kch > DIM ? DIM : kchs - kch);
 
                   if (trans_input_3120) {
                     I = batches - b > DIM ? DIM : batches - b;
@@ -1393,961 +1479,278 @@ static void sp_tiled_conv_A_stride(
         for (int orow = 0; orow < orows; orow++)
           for (int ocol = 0; ocol < ocols; ocol += DIM) {
             const int I = ocols - ocol > DIM ? DIM : ocols - ocol;
-  
+
             for (int och = 0; och < ochs; och += DIM) {
               const int J = ochs - och > DIM ? DIM : ochs - och;
-  
+
               const uint32_t C_sp_addr = C_sp_addr_start + (och / DIM) * batches * orows * ocols + b * orows * ocols + orow * ocols + ocol;
-  
+
               elem_t * out = output + (b*out_dim*out_dim + orow*out_dim + ocol) * out_channels + och;
               if (trans_output_1203) {
                 out = output + (orow*out_dim*batch_size + ocol*batch_size + b) * out_channels + och;
               }
-  
+
               gemmini_extended_mvout(out,
                   C_sp_addr,
                   J, I);
             }
           }
     } else {
-      gemmini_extended_config_st(out_channels * sizeof(elem_t), pool_stride, pool_size, pool_out_dim, porows, pocols, orows, ocols, pupad, plpad);
-  
+      gemmini_extended2_config_st(out_channels * sizeof(elem_t), act, scale, pool_stride, pool_size, pool_out_dim, porows, pocols, orows, ocols, pupad, plpad);
+
       for (int b = 0; b < batches; b++) {
         for (int poch = 0; poch < pochs; poch += DIM) {
           const int channels = poch + DIM >= pochs ? pochs - poch : DIM;
-  
+
           elem_t * pout = output + (b * pool_out_dim * pool_out_dim)*out_channels + poch;
-  
+
           const uint32_t C_sp_addr = C_sp_addr_start + (poch / DIM) * batches * orows * ocols + b * orows * ocols;
-  
+
           gemmini_extended_mvout(pout,
               C_sp_addr,
               channels, 0);
         }
       }
-  
-      gemmini_config_st(out_channels * sizeof(elem_t));
+
+      gemmini_extended_config_st(out_channels * sizeof(elem_t), act, scale);
     }
   }
   */
 }
 
-//resnet downsampling layer (no padding, kernel size 1, stride 2)
-//due to poor instruction issue bandwidth
-static void sp_tiled_conv_ds(
-        int batch_size, int in_dim, int in_channels,
-        int out_channels, int out_dim, int pool_out_dim,
 
-        int stride, //int padding, int kernel_dim,
-        int pool_size, int pool_stride, int pool_padding  __attribute__((unused)),
+static void sp_tiled_conv_dw(
+        int batch_size, int in_dim, int channels, int out_dim, int pool_out_dim,
+
+        int stride, int padding, int kernel_dim,
+
+        int pool_size, int pool_stride, int pool_padding,
 
         int batches,
-        int porows, int pocols, int pochs,
-        int kchs,
+        int porows, int pocols,
+        int krows, int kcols,
 
         int lpad, int rpad, int upad, int dpad,
         int plpad, int prpad, int pupad, int pdpad,
 
         const elem_t * input,
-	    uint32_t B_sp_addr_outer,
         const elem_t * weights,
         elem_t * output,
         const acc_t * bias,
 
-	    int act, acc_scale_t scale, int relu6_shift,
-        bool no_bias, bool no_pool,
-	    int weight_bank) {
-
-    // const bool no_padding = lpad == 0 && rpad == 0 && upad == 0 && dpad == 0;
-    // printf("SP_TILED_CONV no_padding: %d", no_padding);
+        int act, acc_scale_t scale,
 
-    const int orows = porows * pool_stride + pool_size - 1 - pupad - pdpad;
-    const int ocols = pocols * pool_stride + pool_size - 1 - plpad - prpad;
-    const int ochs = pochs;
+        bool no_bias, bool no_pool) {
 
-    // Calculate image dimensions
-    const int irows = (orows - 1) * stride + 1;
-    const int icols = (ocols - 1) * stride + 1;//kcols;
-    const int ichs = kchs;
+  const int orows = porows * pool_stride + pool_size - 1 - pupad - pdpad;
+  const int ocols = pocols * pool_stride + pool_size - 1 - plpad - prpad;
 
-	const int im2col_height = ocols*orows;
-    // const int im2col_width = kchs;
-	const int row_left = im2col_height%DIM;
-	const int row_turn = row_left == 0 ? im2col_height/DIM - 1 : im2col_height/DIM;
-	const int double_bank = weight_bank > 1 ? 1 : 0;
-	const int triple_bank = weight_bank > 2 ? 1 : 0;
-
-    int odims = im2col_height;
-
-	  gemmini_extended2_config_ex(WEIGHT_STATIONARY, act, 0, scale, relu6_shift, 1, false, false, ocols, row_turn, 1, stride, kchs, row_left, 1, double_bank, triple_bank); //if want 2 banks for weight, last is 1
-
-    const uint32_t A_sp_addr_start = 0;
-    const uint32_t B_sp_addr_start = B_sp_addr_outer == 0 ? (BANK_NUM - weight_bank) * BANK_ROWS : B_sp_addr_outer;
-    const uint32_t D_sp_addr_start = 1 << (ADDR_LEN - 1);
-    const uint32_t C_sp_addr_start = 3 << (ADDR_LEN - 2);
-
-    // printf("mvin bias\n");
-    // mvin bias
-
-    if (!no_bias && bias != NULL) {
-        // TODO we probably don't need quite this many nested loops for this part
-        gemmini_config_ld(0);
-        for (int b = 0; b < batches; b++)
-          for (int och = 0; och < ochs; och += DIM) {
-               //const int J = ochs - och > DIM ? DIM : ochs - och;
-               const uint32_t D_sp_addr = D_sp_addr_start + (och / DIM) * batches * odims + b * odims;// + odim;
-	        for(int odim = 0; odim < odims; odim += DIM){
- 		    const int I = odims - odim > DIM ? DIM : odims - odim;
-                        gemmini_extended_mvin(bias + och,
-                                D_sp_addr+odim,
-                                DIM, I);
-                    }
-                }
-    }
+  // Calculate image dimensions
+  // Note: "irows" and "icols" includes padding
+  int irows = orows * stride + krows - 1;
+  int icols = ocols * stride + kcols - 1;
+  int irows_unpadded = irows - upad - dpad;
+  int icols_unpadded = icols - lpad - rpad;
 
-   // mvin weights if it hasn't moved-in in outer loop
-//    printf("weight move in \n");
-   if(B_sp_addr_outer == 0){
-    gemmini_config_ld(out_channels*sizeof(elem_t));
-    for (int och = 0; och < ochs; och += DIM) {
-        const int J = ochs - och > DIM ? DIM : ochs - och;
-        const uint32_t B_sp_addr = B_sp_addr_start + (och / DIM) * kchs;
-        for (int kch = 0; kch < kchs; kch += DIM) {
-           const int K = kchs - kch > DIM ? DIM : kchs - kch;
-           gemmini_extended_mvin(weights + kch * out_channels + och,
-                        B_sp_addr+kch,
-                        J, K);
-	}
-    }
-   }
-
-//	gemmini_fence();
- int idims = irows*icols;
-int bidims = batches*idims;
-    // mvin input
-//     printf("mvin inputs\n");
-    gemmini_config_ld(in_channels * sizeof(elem_t));
-
-   for (int b = 0; b < batches; b++) {
-        for (int irow = 0; irow < irows; irow++) {
-                const elem_t * in = input + (b*in_dim*in_dim + irow*in_dim) * in_channels;// + ich;
-       		const uint32_t A_sp_addr = A_sp_addr_start + b * idims + irow * icols;
-                   for (int ich = 0; ich < ichs; ich += DIM) {
-                      // const int K = ichs - ich > DIM ? DIM : ichs - ich;
-                       gemmini_extended_mvin(in+ich,
-                            A_sp_addr + (ich/DIM)*bidims,
-                            DIM, icols);
-		}
-       }
-    }
+#ifdef HAS_FIRST_LAYER_OPTIMIZATIONS
+  int max_pixels_per_row = DIM;
+  if (max_pixels_per_row > kcols) max_pixels_per_row = kcols;
+#else
+  const int max_pixels_per_row = 1;
+#endif
 
-  // Compute
-  // previously attempted to merge with mvout
-//   printf("compute  \n");
-	//gemmini_fence();
-	 if(odims > DIM){ //output dimension (row*col) bigger than DIM
-	   for (int b = 0; b < batches; b++){
-	        for (int och = 0; och < ochs; och += DIM) {
- 		   const uint32_t B_sp_addr = B_sp_addr_start + (och / DIM) * kchs;// + kch;
-     		   const uint32_t C_sp_addr = C_sp_addr_start + (och / DIM) * batches * odims + b * odims;
-
- 		   for (int kch = 0; kch < kchs; kch += DIM) {
-//                	gemmini_extended_mvin(weights + kch * out_channels + och,
-//                        	B_sp_addr+kch,
-//                        	DIM, DIM);
-
-			const uint32_t A_sp_addr = A_sp_addr_start + (kch / DIM)*batches*idims + b*idims;
-            		for(int odim = 0; odim < odims; odim += DIM){ //both dimension at the same time
-				const int I = odims - odim > DIM ? DIM : odims - odim;
-                        	gemmini_extended_preload(B_sp_addr+kch, C_sp_addr+odim,
-                                	 DIM, DIM, DIM, I);
-                        	gemmini_extended_compute_preloaded(A_sp_addr, GARBAGE_ADDR, DIM, I, DIM, I);
-			}
-            	  }
-//	if(output!=NULL) gemmini_extended_mvout(output + (b * out_dim * out_dim)*out_channels + och, C_sp_addr, DIM, 0);
+  // Calculate spad address offsets
+  const int B_rows = kcols * krows;
 
-              }
-     	  }
-  	}else{//ds layer
-	   for (int b = 0; b < batches; b++){
-        	for (int och = 0; och < ochs; och += DIM) {
-  	    		const uint32_t C_sp_addr = C_sp_addr_start + (och / DIM) * batches * odims + b * odims;
-            		int kch_bound = 0;
-  	    		for (int kch = 0; kch + 7*DIM < kchs; kch += 8*DIM) {
-				const uint32_t B_sp_addr = B_sp_addr_start + (och / DIM) * kchs + kch;
-/*
-        			for(int kk = 0; kk < 8*DIM; kk += DIM){
-                    			gemmini_extended_mvin(weights + (kk+kch) * out_channels + och,
-                        			B_sp_addr+kk,
-                        		DIM, DIM);
-				}
-*/
-				const uint32_t A_sp_addr = A_sp_addr_start + (kch / DIM)*bidims + b*idims;
-                		gemmini_extended_preload(B_sp_addr, C_sp_addr,
-                                        DIM, DIM, DIM, odims);
-               		 	gemmini_extended_compute_preloaded(A_sp_addr, GARBAGE_ADDR, DIM, odims, DIM, odims);
-
-                		gemmini_extended_preload(B_sp_addr+DIM, C_sp_addr,
-                                        DIM, DIM, DIM, odims);
-                		gemmini_extended_compute_preloaded(A_sp_addr+bidims, GARBAGE_ADDR, DIM, odims, DIM, odims);
-
-                		gemmini_extended_preload(B_sp_addr+2*DIM, C_sp_addr,
-                                        DIM, DIM, DIM, odims);
-                		gemmini_extended_compute_preloaded(A_sp_addr+2*bidims, GARBAGE_ADDR, DIM, odims, DIM, odims);
-
-                		gemmini_extended_preload(B_sp_addr+3*DIM, C_sp_addr,
-                                        DIM, DIM, DIM, odims);
-                		gemmini_extended_compute_preloaded(A_sp_addr+3*bidims, GARBAGE_ADDR, DIM, odims, DIM, odims);
-
-                		gemmini_extended_preload(B_sp_addr + 4*DIM, C_sp_addr,
-                                        DIM, DIM, DIM, odims);
-                		gemmini_extended_compute_preloaded(A_sp_addr + 4*bidims, GARBAGE_ADDR, DIM, odims, DIM, odims);
-
-                		gemmini_extended_preload(B_sp_addr + 5*DIM, C_sp_addr,
-                                        DIM, DIM, DIM, odims);
-                		gemmini_extended_compute_preloaded(A_sp_addr+5*bidims, GARBAGE_ADDR, DIM, odims, DIM, odims);
-
-				gemmini_extended_preload(B_sp_addr + 6*DIM, C_sp_addr,
-                                        DIM, DIM, DIM, odims);
-                		gemmini_extended_compute_preloaded(A_sp_addr+6*bidims, GARBAGE_ADDR, DIM, odims, DIM, odims);
-
-				gemmini_extended_preload(B_sp_addr + 7 * DIM, C_sp_addr,
-                                        DIM, DIM, DIM, odims);
-				gemmini_extended_compute_preloaded(A_sp_addr+7*bidims, GARBAGE_ADDR, DIM, odims, DIM, odims);
-				kch_bound = kch + 8*DIM;
-
-                	}
-	    //if kch is not divisible by DIM
- 	    		for (; kch_bound < kchs; kch_bound += DIM) {
-//	        		const int K = kchs - kch > DIM ? DIM : kchs - kch;
-				const uint32_t B_sp_addr = B_sp_addr_start + (och / DIM) * kchs + kch_bound;
-//                		gemmini_extended_mvin(weights + kch_bound * out_channels + och,
-//                       		B_sp_addr,
-//                        		DIM, DIM);
-				const uint32_t A_sp_addr = A_sp_addr_start + (kch_bound / DIM)*bidims + b*idims;
-
-		                gemmini_extended_preload(B_sp_addr, C_sp_addr,
-                		           DIM, DIM, DIM, odims);
-                		gemmini_extended_compute_preloaded(A_sp_addr, GARBAGE_ADDR, DIM, odims, DIM, odims);
-
-                	}
-//	const uint32_t C_sp_addr = C_sp_addr_start + (och / DIM) * batches * odims + b * odims;
-//	if(output!=NULL) gemmini_extended_mvout(output + (b * out_dim * out_dim)*out_channels + och, C_sp_addr, DIM, 0);
-
-            	}
-       	   }
-  	}
-
- // mvout output
-//   printf("mvout \n");
-   if (output != NULL) {
-		gemmini_extended_config_st(out_channels * sizeof(elem_t), 0, 1, out_dim, 0, 0, orows, ocols, 0, 0);
-		for(int b = 0; b < batches; b++)
-			for(int och = 0; och < ochs; och += DIM){
-				const uint32_t C_sp_addr = C_sp_addr_start + (och / DIM) * batches * odims + b * odims;
-				gemmini_extended_mvout(output + (b * out_dim * out_dim)*out_channels + och, C_sp_addr, DIM, 0);
-			}
-	}
+  static uint32_t D_sp_addr_row = 0;
+  static uint32_t C_sp_addr_row = 0;
 
-}
+  const uint32_t A_sp_addr_start = 0;
+  const uint32_t B_sp_addr_start = BANK_NUM * BANK_ROWS - B_rows;
+  const uint32_t D_sp_addr_start = (1 << (ADDR_LEN - 1)) + D_sp_addr_row;
+  const uint32_t C_sp_addr_start = (3 << (ADDR_LEN - 2)) + C_sp_addr_row;
 
-static void sp_tiled_conv_dw(
-        int batch_size, int in_dim, int in_channels,
-        int out_channels, int out_dim, int pool_out_dim,
+  if (bias != 0) {
+    D_sp_addr_row = (D_sp_addr_row + ACC_ROWS / 2) % ACC_ROWS;
+  }
 
-        int stride, int padding, int kernel_dim,
+  if (output != 0) {
+    C_sp_addr_row = (C_sp_addr_row + ACC_ROWS / 2) % ACC_ROWS;
+  }
 
-        int pool_size, int pool_stride, int pool_padding,
+  // mvin bias
+  if (bias != NULL) {
+    // TODO we probably don't need quite this many nested loops for this part
 
-        int batches,
-        int porows, int pocols,// int pochs,
-        int lpad, int rpad, int upad, int dpad,
-        int plpad, int prpad, int pupad, int pdpad,
+    gemmini_extended4_config_ld(0, MVIN_SCALE_IDENTITY, false, batches * orows * ocols, 2);
 
-        const elem_t * input,
-        // uint32_t B_sp_addr_start,
-        const elem_t * weights,
-        elem_t * output,
-        const acc_t * bias,
+    for (int b = 0; b < batches; b++)
+      for (int orow = 0; orow < orows; orow++)
+        for (int ocol = 0; ocol < ocols; ocol += DIM) {
+          const int I = ocols - ocol > DIM ? DIM : ocols - ocol;
 
-	    int act, acc_scale_t scale, int relu6_shift,
-        bool no_bias, bool no_pool, bool mvin_weight
-	) {
-
-    const int orows = porows * pool_stride + pool_size - 1 - pupad - pdpad;
-    const int ocols = pocols * pool_stride + pool_size - 1 - plpad - prpad;
-    // Calculate image dimensions
-    const int irows = (orows - 1) * stride + kernel_dim;
-    const int icols = (ocols - 1) * stride + kernel_dim;//kcols;
-    const int irows_unpadded = irows - upad - dpad;
-    const int icols_unpadded = icols - lpad - rpad;
-    int kchs = 1;
-    int kdims = kernel_dim * kernel_dim;
-
-    int double_bank = 0;//weight_bank > 1 ? 1 : 0;
-    int triple_bank = 0;//weight_bank > 2 ? 1 : 0;
-	const int odims = ocols*orows;
-	const int row_left = odims%DIM;
-	const int row_turn = row_left == 0 ? odims/DIM - 1 : odims/DIM;
-	gemmini_extended2_config_ex(WEIGHT_STATIONARY, act, 0, scale, relu6_shift, 1, false, false, ocols, row_turn, kernel_dim, stride, kchs, row_left, kdims, double_bank, triple_bank); //if want 2 banks for weight, last is 1
-
-    int idims = irows*icols;
-    int bidims = batches*idims;
-
-    const uint32_t A_sp_addr_start = 0;
-    const uint32_t B_sp_addr_start = (BANK_NUM-1) * BANK_ROWS;
-    const uint32_t D_sp_addr_start = 1 << (ADDR_LEN - 1);
-    const uint32_t C_sp_addr_start = 3 << (ADDR_LEN - 2);
-
-   if (!no_bias && bias != NULL) {
-       gemmini_config_ld(0);
-       for (int b = 0; b < batches; b++){
-	    const int J = 1;
-	    const uint32_t D_sp_addr = D_sp_addr_start + b * odims;// + odim;
-            for(int odim = 0; odim < odims; odim += DIM){ //both dimension at the same time
-		const int I = odims - odim > DIM ? DIM : odims - odim;
-                gemmini_extended_mvin(bias,// + och,
-                      	D_sp_addr+odim,
-                       	J, I);
-	    }
-	  }
-    }
+          const uint32_t D_sp_addr = D_sp_addr_start + b * orows * ocols + orow * ocols + ocol;
 
-  if (mvin_weight) {
-    // mvin weights
-    // printf("weight move in \n");
-       gemmini_config_ld(out_channels * sizeof(elem_t));
-       for (int krow = 0; krow < kernel_dim; krow++){
-            const uint32_t B_sp_addr = B_sp_addr_start+ krow*kernel_dim;
-
-            for (int kcol = 0; kcol < kernel_dim; kcol++){
-                    gemmini_extended_mvin(weights + (krow*kernel_dim + kcol) * out_channels,
-                        B_sp_addr+kcol,
-                        1, 1);
-	    }
-      }
-    }
+          const acc_t * bias_dram_addr = no_bias ? NULL : bias;
 
-    // mvin input
-    // printf("mvin inputs\n");
-    gemmini_config_ld(in_channels * sizeof(elem_t));
-    static elem_t zeros[MAX_BYTES / sizeof(elem_t)] = {0};
-//    gemmini_fence(); // TODO fix ROB to get rid of this requirement
-    for (int b = 0; b < batches; b++) {
-        for (int irow = -upad; irow < irows_unpadded + dpad; irow++) {
-            const int irow_padded = irow + upad;
-
-            for (int icol = -lpad; icol < icols_unpadded + rpad;) {
-                // TODO There might be some unnecessary mvins here at the edge of the image
-
-                int I = icols_unpadded - icol > DIM ? DIM : icols_unpadded - icol;
-                const elem_t * in = input + (b*in_dim*in_dim + irow*in_dim + icol) * in_channels;// + ich;
-
-                if (icol < 0) {
-                    I = -icol > DIM ? DIM : -icol;
-                } else if (icol >= icols_unpadded) {
-                    I = icols_unpadded + rpad - icol > DIM ? DIM : icols_unpadded + rpad - icol;
-                }
-                const bool is_zeros = irow < 0 || irow >= irows_unpadded || icol < 0 || icol >= icols_unpadded;
-                const int icol_padded = icol + lpad;
-		const uint32_t A_sp_addr = A_sp_addr_start + b * idims + irow_padded * icols + icol_padded;
-		if(is_zeros){
-	           	   gemmini_config_ld(0);
-			//for (int ich = 0; ich < ichs; ich += DIM) {
-                    	   //const int K = ichs - ich > DIM ? DIM : ichs - ich;
-                           in = &zeros[0];
-                           gemmini_extended_mvin(in,//+ich,
-                            A_sp_addr,// + (ich/DIM)*bidims,
-                            1, I);
-                    	//}
-		   gemmini_config_ld(in_channels * sizeof(elem_t));
-
-
-		}else{
-                   //for (int ich = 0; ich < ichs; ich += DIM) {
-                       //const int K = ichs - ich > DIM ? DIM : ichs - ich;
-                       gemmini_extended_mvin(in,//+ich,
-                            A_sp_addr,// + (ich/DIM)*bidims,
-                            1, I);
-
-                   // }
-		}
-                icol += I;
-            }
+          gemmini_extended_mvin3(bias_dram_addr,
+                  D_sp_addr,
+                  1, I);
         }
-    }
-//    gemmini_fence();
-
-//   gemmini_config_ld(0);
-   for (int b = 0; b < batches; b++){
-	    const int J = 1;
-	   //const uint32_t D_sp_addr = D_sp_addr_start + b * odims;// + odim;
-      	    const uint32_t C_sp_addr_outer = C_sp_addr_start + b * odims;// + odim;
-
-		const uint32_t A_sp_addr = A_sp_addr_start + b*idims;
-		const int kkdims = kdims;
-		const uint32_t B_sp_addr = B_sp_addr_start;
-		const int K = 1;
-
-            	for(int odim = 0; odim < odims; odim += DIM){ //both dimension at the same time
-			const int I = odims - odim > DIM ? DIM : odims - odim;
-                        //	gemmini_extended_mvin(bias,// + och,
-                        //        	D_sp_addr+odim,
-                        //        	J, I);
-			const uint32_t C_sp_addr = C_sp_addr_outer + odim;
-
-			for(int kkdim = 0; kkdim < kkdims; kkdim += K){
-                                gemmini_extended_preload(B_sp_addr + kkdim, C_sp_addr,
-                                        J, K, J, I);
-                                gemmini_extended_compute_preloaded(A_sp_addr, GARBAGE_ADDR, K, I, J, I);
-
-                	}
-//		gemmini_extended_mvout(output + (b * out_dim * out_dim)*out_channels, C_sp_addr_outer, J, 0);
-//	   }
-         }
-     }
-
-   // mvout output
-//    printf("mvout \n");
-//    if (output != NULL) {
-//        if (no_pool) {
-            for (int b = 0; b < batches; b++)
-                for (int orow = 0; orow < orows; orow++)
-                    for (int ocol = 0; ocol < ocols; ocol += DIM) {
-                        const int I = ocols - ocol > DIM ? DIM : ocols - ocol;
-                        const uint32_t C_sp_addr = C_sp_addr_start + b * orows * ocols + orow * ocols + ocol;
-
-                        gemmini_extended_mvout(output + (b*out_dim*out_dim + orow*out_dim + ocol) * out_channels,
-                                    C_sp_addr,
-                                    1, I);
-                        }
-}
-
-//for first layer
-static void sp_tiled_conv_first(
-        int batch_size, int in_dim, int in_channels,
-        int out_channels, int out_dim, int pool_out_dim,
+  }
 
-        int stride, int padding, //int kernel_dim,
+  // mvin input
+  {
+    const int max_chs_per_mvin = 1;
 
-        int pool_size, int pool_stride, int pool_padding,
+    const int dram_stride = channels * sizeof(elem_t);
 
-        int batches,
-        int porows, int pocols, int pochs,
-	int krows, int kchs,
+    gemmini_extended5_config_ld(dram_stride, MVIN_SCALE_IDENTITY, false, DIM, max_pixels_per_row, 0);
 
-//        int lpad, int rpad, int upad, int dpad,
-        int plpad, int prpad, int pupad, int pdpad,
+    for (int b = 0; b < batches; b++)
+      for (int irow = -upad; irow < irows_unpadded + dpad; irow++) {
+        const int irow_padded = irow + upad;
 
-        elem_t * input,
-	//uint32_t B_sp_addr_start,
-        elem_t * weights,
-        elem_t * output,
-        acc_t * bias,
-
-	    int act, acc_scale_t scale, int relu6_shift,
-        bool no_bias, bool no_pool, bool mvin_weight,
-	int weight_bank) {
-
-    const int orows = porows * pool_stride + pool_size - 1 - pupad - pdpad;
-    const int ocols = pocols * pool_stride + pool_size - 1 - plpad - prpad;
-    const int ochs = pochs;
-
-    // Calculate image dimensions
-    const int irows = (orows - 1) * stride + krows;
-    const int icols = (ocols - 1) * stride + 1;//krows;
-    int kdims = krows*krows;
-    const int ichs = kchs*krows; //pack rows (kchs: normal channel number)
-
-    int double_bank = weight_bank > 1 ? 1 : 0;
-    int triple_bank = weight_bank > 2 ? 1 : 0;
-    const int odims = ocols*orows;
-    const int row_left = odims%DIM;
-    const int row_turn = row_left == 0 ? odims/DIM - 1 : odims/DIM;
-    gemmini_extended2_config_ex(WEIGHT_STATIONARY, act, 0, scale, relu6_shift, 1, false, false, ocols, row_turn, 1, stride, ichs, row_left, krows, double_bank, triple_bank); //if want 2 banks for weight, last is 1
-
-    int idims = irows*icols;
-    int bidims = batches*idims;
-
-    const uint32_t A_sp_addr_start = 0;
-    const uint32_t B_sp_addr_start = (BANK_NUM - weight_bank) * BANK_ROWS;// - B_rows;
-    const uint32_t D_sp_addr_start = 1 << (ADDR_LEN - 1);
-    const uint32_t C_sp_addr_start = 3 << (ADDR_LEN - 2);
-
-    // printf("mvin bias\n");
-    // mvin bias
-
-    if (!no_bias && bias != NULL) {
-        // TODO we probably don't need quite this many nested loops for this part
-        gemmini_config_ld(0);
-        for (int b = 0; b < batches; b++)
-           for (int och = 0; och < ochs; och += DIM) {
-               const int J = ochs - och > DIM ? DIM : ochs - och;
-               const uint32_t D_sp_addr = D_sp_addr_start + (och / DIM) * batches * odims + b * odims;// + odim;
-	        for(int odim = 0; odim < odims; odim += DIM){
-                   // const int I = ocols - ocol > DIM ? DIM : ocols - ocol;
-		    const int I = odims - odim > DIM ? DIM : odims - odim;
-                        gemmini_extended_mvin(bias + och,
-                                D_sp_addr+odim,
-                                J, I);
-                    }
-                }
-    	   }
-
-//	printf("mvin_weight \n");
-    if(mvin_weight){
-	gemmini_config_ld(out_channels*sizeof(elem_t));
-	  for (int och = 0; och < ochs; och += DIM) {
-       		const int J = ochs - och > DIM ? DIM : ochs - och;
-		for (int ich = 0; ich < ichs; ich += DIM) { //duplication for first layer
-       		    const int K = ichs - ich > DIM ? DIM : ichs - ich;
-        		    for (int krow = 0; krow < krows; krow++){
-	               		   const uint32_t B_sp_addr = B_sp_addr_start + (och / DIM) * krows * ichs+ ich*krows + krow*K;//krow * kcols * kchs + kcol * kchs + kch;
-                      		   gemmini_extended_mvin(weights + (krow*(krows*in_channels) + ich) * out_channels + och,
-                      				B_sp_addr,
-                        			J, K);
-	    			}
-       			    }
-    		  }
-    }
-    // mvin input
-//     printf("mvin inputs\n");
-    gemmini_config_ld(in_channels * sizeof(elem_t));
-    for (int b = 0; b < batches; b++) {
-        for (int irow = 0; irow < irows; irow++) {
-            for (int icol = 0; icol < icols;) {
-                int I = icols - icol > DIM ? DIM : icols- icol;
-                elem_t * in = input + (b*in_dim*in_dim + irow*in_dim + icol) * in_channels;// + ich;
-
-		const uint32_t A_sp_addr = A_sp_addr_start + b * idims + irow * icols + icol;
-                for (int ich = 0; ich < ichs; ich += DIM) {
-                     const int K = ichs - ich > DIM ? DIM : ichs - ich;
-                     gemmini_extended_mvin(in+ich,
-                            A_sp_addr + (ich/DIM)*bidims,
-                            K, I);
+        for (int icol = -lpad; icol < icols_unpadded + rpad;) {
+          // TODO There might be some unnecessary mvins here at the edge of the image
 
-                }
-                icol += I;
-            }
-        }
-    }
+          int I = icols_unpadded - icol > DIM ? DIM : icols_unpadded - icol;
 
-//   printf("matmul computation \n");
-   for (int b = 0; b < batches; b++){
-        for (int och = 0; och < ochs; och += DIM) {
-            const int J = ochs - och > DIM ? DIM : ochs - och;
-	    const uint32_t C_sp_addr = C_sp_addr_start + (och / DIM) * batches * odims + b * odims;// + odim;
-	    for (int kch = 0; kch < ichs; kch += DIM) { //treat as 3x7=21 channels
-	        const int K = ichs - kch > DIM ? DIM : ichs - kch;
-		const uint32_t A_sp_addr = A_sp_addr_start + (kch / DIM)*batches*idims + b*idims;
-		const int kkdims = K*krows;//kdims;
-		const uint32_t B_sp_addr = B_sp_addr_start + (och / DIM) * kchs * kdims + kch*krows;
-
-            	for(int odim = 0; odim < odims; odim += DIM){ //both dimension at the same time
-			const int I = odims - odim > DIM ? DIM : odims - odim;
-			for(int kkdim = 0; kkdim < kkdims; kkdim += K){
-                                gemmini_extended_preload(B_sp_addr + kkdim, C_sp_addr+odim,
-                                        J, K, J, I);
-                                gemmini_extended_compute_preloaded(A_sp_addr, GARBAGE_ADDR, K, I, J, I);
-			}
-                }
-             }
-/*
- //attempt to merge mvout with matmul
-     	       if(output!=NULL){
-                     elem_t * pout = output + (b * pool_out_dim * pool_out_dim)*out_channels + och;
-                    gemmini_extended_mvout(pout,
-                            C_sp_addr,
-                            J, 0);
- 		}
-*/
+          if (icol < 0) {
+            I = -icol > DIM ? DIM : -icol;
+          } else if (icol >= icols_unpadded) {
+            I = icols_unpadded + rpad - icol > DIM ? DIM : icols_unpadded + rpad - icol;
+          }
 
-        }
-   }
-
-    // mvout output
-   if (output != NULL) {
-               gemmini_extended_config_st(out_channels * sizeof(elem_t), pool_stride, pool_size, pool_out_dim, porows, pocols, orows, ocols, pupad, plpad);
-           for (int b = 0; b < batches; b++) {
-               for (int poch = 0; poch < pochs; poch += DIM) {
-                    const int channels = poch + DIM >= pochs ? pochs - poch : DIM;
-                     elem_t * pout = output + (b * pool_out_dim * pool_out_dim)*out_channels + poch;
-                    const uint32_t C_sp_addr = C_sp_addr_start + (poch / DIM) * batches * orows * ocols + b * orows * ocols;
-                    gemmini_extended_mvout(pout,
-                            C_sp_addr,
-                            channels, 0);
-                }
-            }
-   }
-}
+          const int icol_padded = icol + lpad;
 
-//has mvin weight
-static void sp_tiled_conv_ws_original(
-        int batch_size, int in_dim, int in_channels,
-        int out_channels, int out_dim, int pool_out_dim,
+          uint32_t A_sp_addr = A_sp_addr_start + b * irows * icols + irow_padded * icols + icol_padded;
 
-        int stride, int padding, int kernel_dim,
+          const bool is_zeros = irow < 0 || irow >= irows_unpadded || icol < 0 || icol >= icols_unpadded;
 
-        int pool_size, int pool_stride, int pool_padding,
+          const elem_t * in = input + (b*in_dim*in_dim + irow*in_dim + icol) * channels;
+          if (is_zeros) {
+            in = NULL;
+          }
 
-        int batches,
-        int porows, int pocols, int pochs,
-	int krows, int kchs,
+          gemmini_extended_mvin(in,
+              A_sp_addr,
+              1, I);
 
-        int lpad, int rpad, int upad, int dpad,
-        int plpad, int prpad, int pupad, int pdpad,
+          icol += I;
+        }
+      }
+  }
 
-        const elem_t * input,
-        const elem_t * weights,
-        elem_t * output,
-        const acc_t * bias,
+  // mvin weights
+  {
+    gemmini_extended4_config_ld(1, MVIN_SCALE_IDENTITY, false, DIM, 1);
 
-	    int act, int scale, int relu6_shift,
-        bool no_bias, bool no_pool,
-	int weight_bank) {
+    for (int krow = 0; krow < krows; krow++)
+      for (int kcol = 0; kcol < kcols; kcol += DIM) {
+        int K = kcols - kcol > DIM ? DIM : kcols - kcol;
 
-    const int orows = porows * pool_stride + pool_size - 1 - pupad - pdpad;
-    const int ocols = pocols * pool_stride + pool_size - 1 - plpad - prpad;
-    const int ochs = pochs;
+        const uint32_t B_sp_addr = B_sp_addr_start + krow * kcols + kcol;
 
-    // Calculate image dimensions
-    const int irows = (orows - 1) * stride + krows;
-    const int icols = (ocols - 1) * stride + krows;//kcols;
-    const int irows_unpadded = irows - upad - dpad;
-    const int icols_unpadded = icols - lpad - rpad;
-    const int ichs = kchs;
-    int kdims = krows*krows;
-    int idims = irows*icols;
-    int bidims = batches*irows*icols;
-
-    int odims = ocols*orows;
-    const int im2col_width = kdims*kchs;
-    const int row_left = odims%DIM;
-    const int row_turn = row_left == 0 ? odims/DIM - 1 : odims/DIM;
-    const int turn = im2col_width%DIM == 0 ? im2col_width/DIM : im2col_width/DIM + 1;
-    const int double_bank = weight_bank > 1 ? 1 : 0;
-    const int triple_bank = weight_bank > 2 ? 1 : 0;
-    gemmini_extended2_config_ex(WEIGHT_STATIONARY, act, 0, scale, relu6_shift, 1, false, false, ocols, row_turn, krows, stride, kchs, row_left, kdims, double_bank, triple_bank); //if want 2 banks for weight, last is 1
-
-    const uint32_t A_sp_addr_start = 0;
-    const uint32_t B_sp_addr_start = (BANK_NUM - weight_bank) * BANK_ROWS;
-    const uint32_t D_sp_addr_start = 1 << (ADDR_LEN - 1);
-    const uint32_t C_sp_addr_start = 3 << (ADDR_LEN - 2);
-
-    // printf("mvin bias\n");
-    // mvin bias
-    if (!no_bias && bias != NULL) {
-        // TODO we probably don't need quite this many nested loops for this part
-        gemmini_config_ld(0);
-        for (int b = 0; b < batches; b++)
-          for (int och = 0; och < ochs; och += DIM) {
-               const int J = ochs - och > DIM ? DIM : ochs - och;
-               const uint32_t D_sp_addr = D_sp_addr_start + (och / DIM) * batches * odims + b * odims;// + odim;
-	        for(int odim = 0; odim < odims; odim += DIM){
-       		    const int I = odims - odim > DIM ? DIM : odims - odim;
-                    gemmini_extended_mvin(bias + och,
-                                D_sp_addr+odim,
-                                J, I);
-                }
-          }
-    }
+        const elem_t * w = weights + krow*kernel_dim + kcol;
 
-    // mvin weights
-//    printf("weight move in \n");
-    gemmini_config_ld(out_channels * sizeof(elem_t));
-    for (int och = 0; och < ochs; och += DIM) {
-        const int J = ochs - och > DIM ? DIM : ochs - och;
-
-      for (int kch = 0; kch < kchs; kch += DIM) {
-        const int K = kchs - kch > DIM ? DIM : kchs - kch;
-        for (int krow = 0; krow < krows; krow++){
-            const uint32_t B_sp_addr = B_sp_addr_start + (och / DIM) * kdims * kchs + kch*kdims + krow*krows*K;
-
-            for (int kcol = 0; kcol < krows; kcol++){
-                    gemmini_extended_mvin(weights + (krow*kernel_dim*in_channels + kcol*in_channels + kch) * out_channels + och,
-                        B_sp_addr+kcol*K,
-                        J, K);
-	    }
-        }
+        gemmini_extended_mvin2(w, B_sp_addr, 1, K);
       }
-    }
-    // mvin input
-    // printf("mvin inputs\n");
-    gemmini_config_ld(in_channels * sizeof(elem_t));
-    static elem_t zeros[MAX_BYTES / sizeof(elem_t)] = {0};
-//    gemmini_fence(); // TODO fix ROB to get rid of this requirement
-    for (int b = 0; b < batches; b++) {
-        for (int irow = -upad; irow < irows_unpadded + dpad; irow++) {
-            const int irow_padded = irow + upad;
-
-            for (int icol = -lpad; icol < icols_unpadded + rpad;) {
-                int I = icols_unpadded - icol > DIM ? DIM : icols_unpadded - icol;
-                const elem_t * in = input + (b*in_dim*in_dim + irow*in_dim + icol) * in_channels;// + ich;
-
-                if (icol < 0) {
-                    I = -icol > DIM ? DIM : -icol;
-                } else if (icol >= icols_unpadded) {
-                    I = icols_unpadded + rpad - icol > DIM ? DIM : icols_unpadded + rpad - icol;
-                }
-                const bool is_zeros = irow < 0 || irow >= irows_unpadded || icol < 0 || icol >= icols_unpadded;
-                const int icol_padded = icol + lpad;
-		const uint32_t A_sp_addr = A_sp_addr_start + b * idims + irow_padded * icols + icol_padded;
-		if(is_zeros){
-                  	   gemmini_config_ld(0);
-			for (int ich = 0; ich < ichs; ich += DIM) {
-                    	   const int K = ichs - ich > DIM ? DIM : ichs - ich;
-                           in = &zeros[0];
-                           gemmini_extended_mvin(in+ich,
-                            A_sp_addr + (ich/DIM)*bidims,
-                            K, I);
-                         }
-		        gemmini_config_ld(in_channels * sizeof(elem_t));
-		}else{
-                   for (int ich = 0; ich < ichs; ich += DIM) {
-                       const int K = ichs - ich > DIM ? DIM : ichs - ich;
-                       gemmini_extended_mvin(in+ich,
-                            A_sp_addr + (ich/DIM)*bidims,
-                            K, I);
-                    }
-		}
-                icol += I;
-            }
-        }
-    }
-//    gemmini_fence(); // TODO fix ROB to get rid of this requirement
-  // Compute
-   for (int b = 0; b < batches; b++){
-        for (int och = 0; och < ochs; och += DIM) {
-            const int J = ochs - och > DIM ? DIM : ochs - och;
- 	    for (int kch = 0; kch < kchs; kch += DIM) {
-	        const int K = kchs - kch > DIM ? DIM : kchs - kch;
-		const uint32_t A_sp_addr = A_sp_addr_start + (kch / DIM)*batches*idims + b*idims;
-		const uint32_t B_sp_addr = B_sp_addr_start + (och / DIM) * kdims * kchs + kch*kdims;
-            	for(int odim = 0; odim < odims; odim += DIM){ //both dimension at the same time
-			const int I = odims - odim > DIM ? DIM : odims - odim;
-     	       	    	const int C_sp_addr = C_sp_addr_start + (och / DIM) * batches * odims + b * odims + odim;
-			for(int kkdim = 0; kkdim < K*kdims; kkdim += K){
-			        gemmini_extended_preload(B_sp_addr+kkdim, C_sp_addr,
-                                        J, K, J, I);
-                                gemmini_extended_compute_preloaded(A_sp_addr, GARBAGE_ADDR, K, I, J, I);
-			}
-                    }
-                }
-            }
-       }
-
-    // mvout output
-   if (output != NULL) {
-        if (no_pool) {
-            for (int b = 0; b < batches; b++)
-                for (int orow = 0; orow < orows; orow++)
-                    for (int ocol = 0; ocol < ocols; ocol += DIM) {
-                        const int I = ocols - ocol > DIM ? DIM : ocols - ocol;
-
-                        for (int och = 0; och < ochs; och += DIM) {
-                            const int J = ochs - och > DIM ? DIM : ochs - och;
-		            const uint32_t C_sp_addr = C_sp_addr_start + (och / DIM) * batches * orows * ocols + b * orows * ocols + orow * ocols + ocol;
-
-                            gemmini_extended_mvout(output + (b*out_dim*out_dim + orow*out_dim + ocol) * out_channels + och,
-                                    C_sp_addr,
-                                    J, I);
-                        }
+  }
 
-                    }
+  // Compute
+  {
+    for (int krow = 0; krow < krows; krow++) {
+      for (int kcol = 0; kcol < kcols; kcol += max_pixels_per_row) {
+        bool new_weights = true;
 
-	   } else {
-//		   printf("pool \n");
-              gemmini_extended_config_st(out_channels * sizeof(elem_t), pool_stride, pool_size, pool_out_dim, porows, pocols, orows, ocols, pupad, plpad);
-            gemmini_fence(); // TODO remove this when the ROB can accurately handle these
-            for (int b = 0; b < batches; b++) {
-                for (int poch = 0; poch < pochs; poch += DIM) {
-                    const int channels = poch + DIM >= pochs ? pochs - poch : DIM;
-                    elem_t * pout = output + (b * pool_out_dim * pool_out_dim)*out_channels + poch;
-                    const uint32_t C_sp_addr = C_sp_addr_start + (poch / DIM) * batches * orows * ocols + b * orows * ocols;
-                    gemmini_extended_mvout(pout,
-                            C_sp_addr,
-                            channels, 0);
-                }
-            }
-            gemmini_fence(); // TODO remove this when the ROB can accurately handle these
-       }
-   }
+        for (int b = 0; b < batches; b++) {
+          for (int orow = 0; orow < orows; orow++) {
+            for (int ocol = 0; ocol < ocols; ocol += DIM) {
 
-}
+              int irow = orow * stride + krow;
+              int icol = ocol * stride + kcol;
 
-//first layer padding region
-static void sp_tiled_conv_ws_original_first(
-        int batch_size, int in_dim, int in_channels,
-        int out_channels, int out_dim, int pool_out_dim,
+              const int pixels = kcols - kcol > max_pixels_per_row ?
+                max_pixels_per_row : kcols - kcol;
 
-        int stride, int padding, int kernel_dim,
+              const uint32_t C_sp_addr = C_sp_addr_start + b * orows * ocols + orow * ocols + ocol;
 
-        int pool_size, int pool_stride, int pool_padding,
+              // Over here, construct a new matrix
+              //
+              // Let us assume that we only ever operate on
+              // one pixel in one row.
+              // Thus, krows == kcols == 1
+              //
+              // Then, for every set of I, J, and K values
+              //     - I = ocols
+              //     - J = ochs
+              //     - K = kchs
 
-        int batches,
-        int porows, int pocols, int pochs,
-	int krows, int kchs,
+              int I = ocols - ocol > DIM ? DIM : ocols - ocol;
+              const int J = 1;
+              const int K = pixels;
 
-        int lpad, int rpad, int upad, int dpad,
-        int plpad, int prpad, int pupad, int pdpad,
+              const uint32_t A_sp_addr = A_sp_addr_start + b * irows * icols + irow * icols + icol;
 
-        elem_t * input,
-        elem_t * weights,
-        elem_t * output,
-        acc_t * bias,
+              uint32_t B_sp_addr = B_sp_addr_start + krow * kcols + kcol;
 
-        int act, acc_scale_t scale, int relu6_shift,
-        bool no_bias, bool no_pool, bool mvin_weight,
-	int weight_bank) {
+              const uint32_t pre_sp_addr = new_weights ?
+                B_sp_addr : GARBAGE_ADDR;
 
-    const int orows = porows * pool_stride + pool_size - 1 - pupad - pdpad;
-    const int ocols = pocols * pool_stride + pool_size - 1 - plpad - prpad;
-    const int ochs = pochs;
+              // perform matmul
+              gemmini_extended_preload(pre_sp_addr, C_sp_addr, J, K, J, I);
 
-    // Calculate image dimensions
-    const int irows = (orows - 1) * stride + krows;
-    const int icols = (ocols - 1) * stride + krows;//kcols;
-    const int irows_unpadded = irows - upad - dpad;
-    const int icols_unpadded = icols - lpad - rpad;
-    const int ichs = kchs;
-    int kdims = krows*krows;
-int idims = irows*icols;
-int bidims = batches*irows*icols;
-
-    int odims = ocols*orows;
-    const int row_left = odims%DIM;
-    const int row_turn = row_left == 0 ? odims/DIM - 1 : odims/DIM;
-    const int double_bank = weight_bank > 1 ? 1 : 0;
-    const int triple_bank = weight_bank > 2 ? 1 : 0;
-    gemmini_extended2_config_ex(WEIGHT_STATIONARY, act, 0, scale, relu6_shift, 1, false, false, ocols, row_turn, krows, stride, kchs, row_left, kdims, double_bank, triple_bank); //if want 2 banks for weight, last is 1
-
-    const uint32_t A_sp_addr_start = 0;
-    const uint32_t B_sp_addr_start = (BANK_NUM - weight_bank) * BANK_ROWS;
-    const uint32_t D_sp_addr_start = 1 << (ADDR_LEN - 1);
-    const uint32_t C_sp_addr_start = 3 << (ADDR_LEN - 2);
-
-    // printf("mvin bias\n");
-    // mvin bias
-    if (!no_bias && bias != NULL) {
-        // TODO we probably don't need quite this many nested loops for this part
-        gemmini_config_ld(0);
-        for (int b = 0; b < batches; b++)
-          for (int och = 0; och < ochs; och += DIM) {
-               const int J = ochs - och > DIM ? DIM : ochs - och;
-               const uint32_t D_sp_addr = D_sp_addr_start + (och / DIM) * batches * odims + b * odims;// + odim;
-	        for(int odim = 0; odim < odims; odim += DIM){
-		    const int I = odims - odim > DIM ? DIM : odims - odim;
-                    gemmini_extended_mvin(bias + och,
-                                D_sp_addr+odim,
-                                J, I);
-                }
-           }
-    }
+              if (new_weights) {
+                gemmini_extended_compute_preloaded(A_sp_addr, GARBAGE_ADDR, K, I, J, I);
+              } else {
+                gemmini_extended_compute_accumulated(A_sp_addr, GARBAGE_ADDR, K, I, J, I);
+              }
 
-    // mvin input
-    // printf("mvin inputs\n");
-    gemmini_config_ld(in_channels * sizeof(elem_t));
-    static elem_t zeros[MAX_BYTES / sizeof(elem_t)] = {0};
-   for (int b = 0; b < batches; b++) {
-        for (int irow = -upad; irow < irows_unpadded + dpad; irow++) {
-            const int irow_padded = irow + upad;
-
-            for (int icol = -lpad; icol < icols_unpadded + rpad;) {
-                int I = icols_unpadded - icol > DIM ? DIM : icols_unpadded - icol;
-                elem_t * in = input + (b*in_dim*in_dim + irow*in_dim + icol) * in_channels;// + ich;
-
-                if (icol < 0) {
-                    I = -icol > DIM ? DIM : -icol;
-                } else if (icol >= icols_unpadded) {
-                    I = icols_unpadded + rpad - icol > DIM ? DIM : icols_unpadded + rpad - icol;
-                }
-                const bool is_zeros = irow < 0 || irow >= irows_unpadded || icol < 0 || icol >= icols_unpadded;
-                const int icol_padded = icol + lpad;
-		const uint32_t A_sp_addr = A_sp_addr_start + b * idims + irow_padded * icols + icol_padded;
-		if(is_zeros){
-                        gemmini_config_ld(0);
-                        in = &zeros[0];
-                        gemmini_extended_mvin(in,
-                            A_sp_addr,
-                            ichs, I);
-	 	        gemmini_config_ld(in_channels * sizeof(elem_t));
-		}else{
-                      gemmini_extended_mvin(in,
-                            A_sp_addr,
-                            ichs, I);
-
-       		}
-                icol += I;
+              new_weights = false;
             }
+          }
         }
+      }
     }
-//    gemmini_fence(); // TODO fix ROB to get rid of this requirement
+  }
 
-  if(mvin_weight){
-    gemmini_config_ld(out_channels * sizeof(elem_t));
-    for (int och = 0; och < ochs; och += DIM) {
-        const int J = ochs - och > DIM ? DIM : ochs - och;
-        const int K = kchs;//kchs - kch > DIM ? DIM : kchs - kch;
-        for (int krow = 0; krow < krows; krow++){
-            const uint32_t B_sp_addr = B_sp_addr_start + (och / DIM) * kdims * kchs + krow*krows*K;
-
-            for (int kcol = 0; kcol < krows; kcol++){
-                    gemmini_extended_mvin(weights + (krow*kernel_dim*in_channels + kcol*in_channels) * out_channels + och,
-                        B_sp_addr+kcol*K,
-                        J, K);
-	    }
-        }
+  // mvout output
+  if (output != NULL) {
+    if (no_pool) {
+      for (int b = 0; b < batches; b++)
+        for (int orow = 0; orow < orows; orow++)
+          for (int ocol = 0; ocol < ocols; ocol += DIM) {
+            const int I = ocols - ocol > DIM ? DIM : ocols - ocol;
 
-    }
-  }
+            const uint32_t C_sp_addr = C_sp_addr_start + b * orows * ocols + orow * ocols + ocol;
 
-  // Compute
-//if(krows != 1){
-    for (int b = 0; b < batches; b++){
-        for (int och = 0; och < ochs; och += DIM) {
-            const int J = ochs - och > DIM ? DIM : ochs - och;
-      	    const uint32_t C_sp_addr = C_sp_addr_start + (och / DIM) * batches * odims + b * odims;// + odim;
-	    const int K = kchs;// - kch > DIM ? DIM : kchs - kch;
-	    const uint32_t A_sp_addr = A_sp_addr_start + b*idims;
-	    const uint32_t B_sp_addr = B_sp_addr_start + (och / DIM) * kdims * kchs;// + kch*kdims;
-            for(int odim = 0; odim < odims; odim += DIM){ //both dimension at the same time
-		const int I = odims - odim > DIM ? DIM : odims - odim;
-     		for(int kkdim = 0; kkdim < K*kdims; kkdim += K){
-		        gemmini_extended_preload(B_sp_addr+kkdim, C_sp_addr+odim,
-                                J, K, J, I);
-                        gemmini_extended_compute_preloaded(A_sp_addr, GARBAGE_ADDR, K, I, J, I);
-		}
-            }
-/*
- //attempt to merge matmul and mvout
-                    elem_t * pout = output + (b * pool_out_dim * pool_out_dim)*out_channels + och;
-                    gemmini_extended_mvout(pout,
-                            C_sp_addr,
-                            J, 0);
-*/
-	}
-    }
+            elem_t * out = output + (b*out_dim*out_dim + orow*out_dim + ocol) * channels;
 
-   if (output != NULL) {
-           gemmini_extended_config_st(out_channels * sizeof(elem_t), pool_stride, pool_size, pool_out_dim, porows, pocols, orows, ocols, pupad, plpad);
-           for (int b = 0; b < batches; b++) {
-                for (int poch = 0; poch < pochs; poch += DIM) {
-                    const int channels = poch + DIM >= pochs ? pochs - poch : DIM;
+            gemmini_extended_mvout(out,
+                C_sp_addr,
+                1, I);
+        }
+    } else {
+      gemmini_extended2_config_st(channels * sizeof(elem_t), act, scale, pool_stride, pool_size, pool_out_dim, porows, pocols, orows, ocols, pupad, plpad);
 
-                    elem_t * pout = output + (b * pool_out_dim * pool_out_dim)*out_channels + poch;
+      for (int b = 0; b < batches; b++) {
+        elem_t * pout = output + (b * pool_out_dim * pool_out_dim)*channels;
 
-                    const uint32_t C_sp_addr = C_sp_addr_start + (poch / DIM) * batches * orows * ocols + b * orows * ocols;
+        const uint32_t C_sp_addr = C_sp_addr_start + b * orows * ocols;
 
-                    gemmini_extended_mvout(pout,
-                            C_sp_addr,
-                            channels, 0);
-                }
-            }
-   }
+        gemmini_extended_mvout(pout,
+            C_sp_addr,
+            1, 0);
+      }
 
+      gemmini_extended_config_st(channels * sizeof(elem_t), act, scale);
+    }
+  }
 }
 
-static int tiled_conv_total_spad_rows(bool acc, bool weight,
+
+static int tiled_conv_total_spad_rows_dw(bool acc, bool weight,
         int stride,
         int batches,
         int porows, int pocols, int ochs,
@@ -2376,7 +1779,8 @@ static int tiled_conv_total_spad_rows(bool acc, bool weight,
         return A_rows;
 }
 
-static int tiled_conv_total_spad_rows_A_stride(bool acc,
+
+static int tiled_conv_total_spad_rows(bool acc,
         int stride,
         int input_dilation,
         int kernel_dilation,
@@ -2418,6 +1822,7 @@ static int tiled_conv_total_spad_rows_A_stride(bool acc,
     return acc ? C_rows : A_rows + B_rows;
 }
 
+
 static void conv_cpu_without_pool(
         int batch_size, int in_dim, int in_channels,
         int out_channels, int out_dim,
@@ -2493,41 +1898,88 @@ static void conv_cpu_without_pool(
   }
 }
 
-static void conv_cpu(
-        int batch_size, int in_dim, int in_channels,
-        int out_channels, int out_dim,
-        int stride, int input_dilation, int kernel_dilation, int padding, int kernel_dim,
-        bool wrot180, bool trans_output_1203, bool trans_input_3120,
-        bool trans_weight_1203, bool trans_weight_0132,
+
+static void conv_dw_cpu_without_pool(
+        int batch_size, int in_dim, int channels, int out_dim,
+        int stride, int padding, int kernel_dim,
 
         const elem_t * input,
         const elem_t * weights,
         const acc_t * bias,
         elem_t * output,
 
-        int act, acc_scale_t scale, size_t relu6_shift,
-        int pool_size, int pool_stride, int pool_padding) {
-
-  const bool no_pool = pool_stride == 0;
-  if (no_pool) {
-    conv_cpu_without_pool(
-        batch_size, in_dim, in_channels,
-        out_channels, out_dim,
-        stride, input_dilation, kernel_dilation, padding, kernel_dim,
-        wrot180, trans_output_1203, trans_input_3120,
-        trans_weight_1203, trans_weight_0132,
-        input, weights, bias, output,
-        act, scale, relu6_shift);
-    return;
-  }
+        int act, acc_scale_t scale, size_t relu6_shift) {
 
-  const bool no_bias = bias == NULL;
-  const int pool_out_dim = (out_dim + 2*pool_padding - pool_size) / pool_stride + 1;
+  bool no_bias = bias == NULL;
 
   for (int b = 0; b < batch_size; b++) {
-    for (int porow = 0; porow < pool_out_dim; porow++) {
-      for (int pocol = 0; pocol < pool_out_dim; pocol++) {
-        for (int poch = 0; poch < out_channels; poch++) {
+    for (int orow = 0; orow < out_dim; orow++) {
+      for (int ocol = 0; ocol < out_dim; ocol++) {
+        for (int ch = 0; ch < channels; ch++) {
+          acc_t opixel = no_bias ? 0 : bias[ch];
+
+          for (int krow = 0; krow < kernel_dim; krow++) {
+            const int irow = orow * stride + krow - padding;
+
+            for (int kcol = 0; kcol < kernel_dim; kcol++) {
+              const int icol = ocol * stride + kcol - padding;
+
+              const elem_t * in = input + (b * in_dim * in_dim + irow * in_dim + icol) * channels + ch;
+
+              const elem_t ipixel = irow < 0 || irow >= in_dim || icol < 0 || icol >= in_dim ?
+                  0 : *in;
+
+              const elem_t weight = *(weights + (ch * kernel_dim + krow) * kernel_dim  + kcol);
+
+              opixel += weight * ipixel;
+            }
+          }
+
+          elem_t * out = output+(b*out_dim*out_dim+orow*out_dim+ocol)*channels + ch;
+
+          *out = scale_and_sat(opixel, act, scale, relu6_shift);
+        }
+      }
+    }
+  }
+}
+
+
+static void conv_cpu(
+        int batch_size, int in_dim, int in_channels,
+        int out_channels, int out_dim,
+        int stride, int input_dilation, int kernel_dilation, int padding, int kernel_dim,
+        bool wrot180, bool trans_output_1203, bool trans_input_3120,
+        bool trans_weight_1203, bool trans_weight_0132,
+
+        const elem_t * input,
+        const elem_t * weights,
+        const acc_t * bias,
+        elem_t * output,
+
+        int act, acc_scale_t scale, size_t relu6_shift,
+        int pool_size, int pool_stride, int pool_padding) {
+
+  const bool no_pool = pool_stride == 0;
+  if (no_pool) {
+    conv_cpu_without_pool(
+        batch_size, in_dim, in_channels,
+        out_channels, out_dim,
+        stride, input_dilation, kernel_dilation, padding, kernel_dim,
+        wrot180, trans_output_1203, trans_input_3120,
+        trans_weight_1203, trans_weight_0132,
+        input, weights, bias, output,
+        act, scale, relu6_shift);
+    return;
+  }
+
+  const bool no_bias = bias == NULL;
+  const int pool_out_dim = (out_dim + 2*pool_padding - pool_size) / pool_stride + 1;
+
+  for (int b = 0; b < batch_size; b++) {
+    for (int porow = 0; porow < pool_out_dim; porow++) {
+      for (int pocol = 0; pocol < pool_out_dim; pocol++) {
+        for (int poch = 0; poch < out_channels; poch++) {
 
           elem_t running_max = 0;
           bool running_max_initialized = false;
@@ -2610,7 +2062,94 @@ static void conv_cpu(
   }
 }
 
-static void tiled_conv_A_stride(
+
+static void conv_dw_cpu(
+        int batch_size, int in_dim, int channels, int out_dim,
+        int stride, int padding, int kernel_dim,
+
+        const elem_t * input,
+        const elem_t * weights,
+        const acc_t * bias,
+        elem_t * output,
+
+        int act, acc_scale_t scale, size_t relu6_shift,
+        int pool_size, int pool_stride, int pool_padding) {
+
+  const bool no_pool = pool_stride == 0;
+  if (no_pool) {
+    conv_dw_cpu_without_pool(
+        batch_size, in_dim, channels, out_dim,
+        stride, padding, kernel_dim,
+        input, weights, bias, output,
+        act, scale, relu6_shift);
+    return;
+  }
+
+  const bool no_bias = bias == NULL;
+  const int pool_out_dim = (out_dim + 2*pool_padding - pool_size) / pool_stride + 1;
+
+  for (int b = 0; b < batch_size; b++) {
+    for (int porow = 0; porow < pool_out_dim; porow++) {
+      for (int pocol = 0; pocol < pool_out_dim; pocol++) {
+        for (int ch = 0; ch < channels; ch++) {
+
+          elem_t running_max = 0;
+          bool running_max_initialized = false;
+
+          for (int pwrow = 0; pwrow < pool_size; pwrow++) {
+            const int orow = porow * pool_stride + pwrow - pool_padding;
+
+            for (int pwcol = 0; pwcol < pool_size; pwcol++) {
+              const int ocol = pocol * pool_stride + pwcol - pool_padding;
+
+              if (orow < 0 || orow >= out_dim || ocol < 0 || ocol >= out_dim) {
+                if (!running_max_initialized || running_max < 0) {
+                  running_max = 0;
+                  running_max_initialized = true;
+                }
+              } else {
+
+                acc_t opixel = no_bias ? 0 : bias[ch];
+
+                for (int krow = 0; krow < kernel_dim; krow++) {
+                  const int irow = orow * stride + krow - padding;
+
+                  for (int kcol = 0; kcol < kernel_dim; kcol++) {
+                    const int icol = ocol * stride + kcol - padding;
+
+                    const elem_t * in = input + (b * in_dim * in_dim + irow * in_dim + icol) * channels + ch;
+
+                    elem_t ipixel = irow < 0 || irow >= in_dim || icol < 0 || icol >= in_dim ?
+                        0 : *in;
+
+                    const elem_t weight = *(weights + (ch * kernel_dim + krow) * kernel_dim  + kcol);
+
+                    opixel += weight * ipixel;
+                  }
+                }
+
+                opixel = scale_and_sat(opixel, act, scale, relu6_shift);
+                if (!running_max_initialized || opixel > running_max) {
+                  running_max = opixel;
+                  running_max_initialized = true;
+                }
+              }
+
+              if (pwrow == pool_size - 1 && pwcol == pool_size - 1) {
+                elem_t * out = output + (b*pool_out_dim*pool_out_dim + porow*pool_out_dim + pocol)*channels + ch;
+
+                *out = running_max;
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+}
+
+
+static void tiled_conv(
         int batch_size, int in_dim, int in_channels,
         int out_channels, int out_dim,
         int stride, int input_dilation, int kernel_dilation, int padding, int kernel_dim,
@@ -2684,10 +2223,10 @@ static void tiled_conv_A_stride(
         // const int ocols = pocols * pool_stride + pool_size - 1;
 
         // Check that data will fit in scratchpad
-        const int spad_rows = tiled_conv_total_spad_rows_A_stride(false,
+        const int spad_rows = tiled_conv_total_spad_rows(false,
             stride, input_dilation, kernel_dilation, downsample, trans_weight_0132, trans_input_3120,
             batches, porows, pocols, pochs, krows, kcols, kchs, pool_size, pool_stride);
-        const int acc_rows = tiled_conv_total_spad_rows_A_stride(true,
+        const int acc_rows = tiled_conv_total_spad_rows(true,
             stride, input_dilation, kernel_dilation, downsample, trans_weight_0132, trans_input_3120,
             batches, porows, pocols, pochs, krows, kcols, kchs, pool_size, pool_stride);
 
@@ -2725,9 +2264,9 @@ static void tiled_conv_A_stride(
     const size_t st_dram_stride = trans_output_1203 ?
         batch_size * out_channels * sizeof(elem_t) :
         out_channels * sizeof(elem_t);
-    gemmini_config_st(st_dram_stride);
+    gemmini_extended_config_st(st_dram_stride, act, scale);
 
-    gemmini_extended3_config_ex(WEIGHT_STATIONARY, act, 0, scale, relu6_shift, input_dilation, stride >> downsample, trans_input_3120, trans_weight_0132, 0, 0, 0, 0, 0, 0, 0, 0, 0, false);
+    gemmini_extended3_config_ex(WEIGHT_STATIONARY, 0, 0, 0, relu6_shift, input_dilation, stride >> downsample, trans_input_3120, trans_weight_0132, 0, 0, 0, 0, 0, 0, 0, 0, 0, false);
 
     const int pool_out_dim = (out_dim + 2*pool_padding - pool_size) / pool_stride + 1;
     const int dilated_in_dim = in_dim + (input_dilation-1)*(in_dim-1);
@@ -2820,7 +2359,7 @@ static void tiled_conv_A_stride(
                                   in = input + (kch*in_dim*in_dim + ((irow+upad)>>input_dilated)*in_dim + ((icol+lpad)>>input_dilated)) * batch_size + b;
                                 }
 
-                                sp_tiled_conv_A_stride(
+                                sp_tiled_conv(
                                     batch_size, in_dim, in_channels,
                                     out_channels, out_dim, pool_out_dim,
 
@@ -2840,6 +2379,8 @@ static void tiled_conv_A_stride(
                                     out,
                                     bias_,
 
+                                    act, scale,
+
                                     wrot180, trans_output_1203, trans_input_3120,
                                     trans_weight_1203, trans_weight_0132,
 
@@ -2853,7 +2394,182 @@ static void tiled_conv_A_stride(
     }
 }
 
-static void tiled_conv_A_stride_auto(
+
+static void tiled_conv_dw(
+    int batch_size, int in_dim, int channels, int out_dim,
+    int stride, int padding, int kernel_dim,
+
+    int batches,
+    int porows, int pocols, int chs,
+    int krows, int kcols,
+
+    const elem_t * input,
+    const elem_t * weights,
+    const acc_t * bias,
+    elem_t * output,
+
+    int act, acc_scale_t scale, size_t relu6_shift,
+    int pool_size, int pool_stride, int pool_padding,
+
+    enum tiled_matmul_type_t tiled_conv_type) {
+
+    if (tiled_conv_type == CPU) {
+      if (pool_size == 1 && pool_stride == 1 && pool_padding == 0) {
+        pool_stride = 0;
+      }
+
+      conv_dw_cpu(
+        batch_size, in_dim, channels, out_dim,
+        stride, padding, kernel_dim,
+        input, weights, bias, output,
+        act, scale, relu6_shift,
+        pool_size, pool_stride, pool_padding);
+      return;
+    } else if (tiled_conv_type == OS) {
+      printf("Gemmini convs do not currently support OS\n");
+      exit(1);
+    }
+
+    // TODO move everything below this into a tiled_conv_outer function to match the tiled_matmul function
+
+    bool no_bias = false;
+    if (bias == NULL) {
+        bias = (acc_t*)1;
+        no_bias = true;
+    }
+
+    bool no_pool = pool_stride == 0;
+    if (no_pool) {
+        pool_size = 1;
+        pool_stride = 1;
+        pool_padding = 0;
+    }
+
+#ifdef GEMMINI_ASSERTIONS
+    {
+        // const int orows = porows * pool_stride + pool_size - 1;
+        // const int ocols = pocols * pool_stride + pool_size - 1;
+
+        // Check that data will fit in scratchpad
+        const int spad_rows = tiled_conv_total_spad_rows(false,
+            stride, 1, 1, false, false, false,
+            batches, porows, pocols, chs, krows, kcols, 1, pool_size, pool_stride);
+        const int acc_rows = tiled_conv_total_spad_rows(true,
+            stride, 1, 1, false, false, false,
+            batches, porows, pocols, chs, krows, kcols, 1, pool_size, pool_stride);
+
+        if (spad_rows > BANK_NUM * BANK_ROWS / 2) {
+            printf("not enough scratchpad space to store inputs and weights, %d\n", spad_rows);
+            exit(1);
+        }
+        if (acc_rows > ACC_ROWS / 2) {
+            printf("not enough accumulator space to store outputs\n");
+            exit(1);
+        }
+        if (kernel_dim <= padding) {
+            printf("kernel_dim must be larger than padding\n");
+            exit(1);
+        }
+    }
+#endif
+
+    const size_t st_dram_stride = channels * sizeof(elem_t);
+    gemmini_extended_config_st(st_dram_stride, act, scale);
+
+    gemmini_extended3_config_ex(WEIGHT_STATIONARY, 0, 0, 0, relu6_shift, 1, stride, false, false, 0, 0, 0, 0, 0, 0, 0, 0, 0, false);
+
+    const int pool_out_dim = (out_dim + 2*pool_padding - pool_size) / pool_stride + 1;
+
+    for (int b = 0; b < batch_size; b += batches) {
+        for (int porow = 0; porow < pool_out_dim; porow += porows) {
+            const int orow = porow * pool_stride - pool_padding;
+
+            for (int pocol = 0; pocol < pool_out_dim; pocol += pocols) {
+                const int ocol = pocol * pool_stride - pool_padding;
+
+                for (int ch = 0; ch < channels; ch += chs) {
+                    for (int krow = 0; krow < kernel_dim; krow += krows) {
+                        const int orow_floored = orow < 0 ? 0 : orow;
+                        int irow = orow_floored * stride + krow - padding;
+
+                        for (int kcol = 0; kcol < kernel_dim; kcol += kcols) {
+                            const int ocol_floored = ocol < 0 ? 0 : ocol;
+                            int icol = ocol_floored * stride + kcol - padding;
+
+                            elem_t * out = output + (b*pool_out_dim*pool_out_dim + porow*pool_out_dim + pocol) * channels + ch;
+
+                            if (krow + krows < kernel_dim ||
+                                    kcol + kcols < kernel_dim) {
+                                out = NULL;
+                            }
+
+                            const acc_t * bias_ = bias + ch;
+                            if (krow > 0 ||
+                                    kcol > 0) {
+                                bias_ = NULL;
+                            }
+
+                            const int batches_ = batch_size - b > batches ? batches : batch_size - b;
+                            const int porows_ = pool_out_dim - porow > porows ? porows : pool_out_dim - porow;
+                            const int pocols_ = pool_out_dim - pocol > pocols ? pocols : pool_out_dim - pocol;
+                            const int chs_ = channels - ch > chs ? chs : channels - ch;
+                            const int krows_ = kernel_dim - krow > krows ? krows : kernel_dim - krow;
+                            const int kcols_ = kernel_dim - kcol > kcols ? kcols : kernel_dim - kcol;
+
+                            const int ocols_ = pocols_ * pool_stride + pool_size - 1;
+                            const int orows_ = porows_ * pool_stride + pool_size - 1;
+
+                            const int plpad = ocol < 0 ? -ocol : 0;
+                            const int prpad = ocol + ocols_ > out_dim ? ocol + ocols_ - out_dim : 0;
+                            const int pupad = orow < 0 ? -orow : 0;
+                            const int pdpad = orow + orows_ > out_dim ? orow + orows_ - out_dim : 0;
+
+                            const int icols_ = (ocols_ - plpad - prpad) * stride + kcols_ - 1;
+                            const int irows_ = (orows_ - pupad - pdpad) * stride + krows_ - 1;
+
+                            int lpad = icol < 0 ? -icol : 0;
+                            int rpad = icol + icols_ > in_dim ? icol + icols_ - in_dim : 0;
+                            int upad = irow < 0 ? -irow : 0;
+                            int dpad = irow + irows_ > in_dim ? irow + irows_ - in_dim : 0;
+
+                            const elem_t * weights_slice = weights + (ch*kernel_dim + krow) * kernel_dim + kcol;
+
+                            const elem_t * in = input + (b*in_dim*in_dim + (irow+upad)*in_dim + (icol+lpad)) * channels + ch;
+
+                            sp_tiled_conv_dw(
+                                batch_size, in_dim, channels,
+                                out_dim, pool_out_dim,
+
+                                stride, padding, kernel_dim,
+
+                                pool_size, pool_stride, pool_padding,
+
+                                batches_,
+                                porows_, pocols_,
+                                krows_, kcols_,
+
+                                lpad, rpad, upad, dpad,
+                                plpad, prpad, pupad, pdpad,
+
+                                in,
+                                weights_slice,
+                                out,
+                                bias_,
+
+                                act, scale,
+
+                                no_bias, no_pool);
+
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
+
+
+static void tiled_conv_auto(
         int batch_size, int in_dim, int in_channels,
         int out_channels, int out_dim,
         int stride, int input_dilation, int kernel_dilation, int padding, int kernel_dim,
@@ -2896,10 +2612,10 @@ static void tiled_conv_A_stride_auto(
     const int max_spad_rows = (BANK_NUM*BANK_ROWS / 2);
     const int max_acc_rows = (ACC_ROWS / 2);
 
-    int spad_rows = tiled_conv_total_spad_rows_A_stride(false,
+    int spad_rows = tiled_conv_total_spad_rows(false,
         stride, input_dilation, kernel_dilation, downsample, trans_weight_0132, trans_input_3120,
         args[0], args[1], args[2], args[3], args[4], args[5], args[6], pool_size, pool_stride);
-    int acc_rows = tiled_conv_total_spad_rows_A_stride(true,
+    int acc_rows = tiled_conv_total_spad_rows(true,
         stride, input_dilation, kernel_dilation, downsample, trans_weight_0132, trans_input_3120,
         args[0], args[1], args[2], args[3], args[4], args[5], args[6], pool_size, pool_stride);
 
@@ -2928,10 +2644,10 @@ static void tiled_conv_A_stride_auto(
             args[max_idx]--;
         }
 
-        spad_rows = tiled_conv_total_spad_rows_A_stride(false,
+        spad_rows = tiled_conv_total_spad_rows(false,
             stride, input_dilation, kernel_dilation, downsample, trans_weight_0132, trans_input_3120,
             args[0], args[1], args[2], args[3], args[4], args[5], args[6], pool_size, pool_stride);
-        acc_rows = tiled_conv_total_spad_rows_A_stride(true,
+        acc_rows = tiled_conv_total_spad_rows(true,
             stride, input_dilation, kernel_dilation, downsample, trans_weight_0132, trans_input_3120,
             args[0], args[1], args[2], args[3], args[4], args[5], args[6], pool_size, pool_stride);
     }
@@ -2947,10 +2663,10 @@ static void tiled_conv_A_stride_auto(
         if (args_candidate[ocols_idx] > max_args[ocols_idx])
             continue;
 
-        spad_rows = tiled_conv_total_spad_rows_A_stride(false,
+        spad_rows = tiled_conv_total_spad_rows(false,
             stride, input_dilation, kernel_dilation, downsample, trans_weight_0132, trans_input_3120,
             args_candidate[0], args_candidate[1], args_candidate[2], args_candidate[3], args_candidate[4], args_candidate[5], args_candidate[6], pool_size, pool_stride);
-        acc_rows = tiled_conv_total_spad_rows_A_stride(true,
+        acc_rows = tiled_conv_total_spad_rows(true,
             stride, input_dilation, kernel_dilation, downsample, trans_weight_0132, trans_input_3120,
             args_candidate[0], args_candidate[1], args_candidate[2], args_candidate[3], args_candidate[4], args_candidate[5], args_candidate[6], pool_size, pool_stride);
 
@@ -2972,10 +2688,10 @@ static void tiled_conv_A_stride_auto(
             if (args_candidate[i] > max_args[i])
                 continue;
 
-            spad_rows = tiled_conv_total_spad_rows_A_stride(false,
+            spad_rows = tiled_conv_total_spad_rows(false,
                 stride, input_dilation, kernel_dilation, downsample, trans_weight_0132, trans_input_3120,
                 args_candidate[0], args_candidate[1], args_candidate[2], args_candidate[3], args_candidate[4], args_candidate[5], args_candidate[6], pool_size, pool_stride);
-            acc_rows = tiled_conv_total_spad_rows_A_stride(true,
+            acc_rows = tiled_conv_total_spad_rows(true,
                 stride, input_dilation, kernel_dilation, downsample, trans_weight_0132, trans_input_3120,
                 args_candidate[0], args_candidate[1], args_candidate[2], args_candidate[3], args_candidate[4], args_candidate[5], args_candidate[6], pool_size, pool_stride);
 
@@ -2995,10 +2711,10 @@ static void tiled_conv_A_stride_auto(
     const int kchs = args[6];
 
     /*
-    spad_rows = tiled_conv_total_spad_rows_A_stride(false,
+    spad_rows = tiled_conv_total_spad_rows(false,
         stride, input_dilation, kernel_dilation, downsample, trans_weight_0132, trans_input_3120,
         args[0], args[1], args[2], args[3], args[4], args[5], args[6], pool_size, pool_stride);
-    acc_rows = tiled_conv_total_spad_rows_A_stride(true,
+    acc_rows = tiled_conv_total_spad_rows(true,
         stride, input_dilation, kernel_dilation, downsample, trans_weight_0132, trans_input_3120,
         args[0], args[1], args[2], args[3], args[4], args[5], args[6], pool_size, pool_stride);
 
@@ -3019,7 +2735,7 @@ static void tiled_conv_A_stride_auto(
     printf("inner matmul size: i=%d, j=%d, k=%d\n\n", ocols, ochs, kchs);
     */
 
-    tiled_conv_A_stride(
+    tiled_conv(
         batch_size, in_dim, in_channels,
         out_channels, out_dim,
         stride, input_dilation, kernel_dilation, padding, kernel_dim,
@@ -3079,1589 +2795,179 @@ static void tiled_conv_downsample(
                     A_stride, B_stride, D_stride, C_stride,
                     MVIN_SCALE_IDENTITY, MVIN_SCALE_IDENTITY,
                     MVIN_SCALE_IDENTITY, act, scale, relu6_shift,
-                    true, false, false, false, false, 3, tiled_conv_type);
+                    true, false, false, false, false, 0, tiled_conv_type);
         }
     }
 }
 
-static void tiled_conv_dw(
-        int batch_size, int in_dim, int in_channels,
-        int out_channels, int out_dim,
-        int stride, int padding, int kernel_dim,
+//for mobilenet's depthwise convs
+static void tiled_conv_dw_auto(
+    int batch_size, int in_dim, int channels, int out_dim,
+    int stride, int padding, int kernel_dim,
 
-        int batches,
-        int porows, int pocols,// int pochs,
-//        int krows, int kcols, int kchs,
+    elem_t * input,
+    elem_t * weights,
+    acc_t * bias,
+    elem_t * output,
 
-        const elem_t * input,
-        const elem_t * weights,
-        const acc_t * bias,
-        elem_t * output,
+    int act, acc_scale_t scale, size_t relu6_shift,
+    int pool_size, int pool_stride, int pool_padding,
 
-        int act, acc_scale_t scale, size_t relu6_shift,
-        int pool_size, int pool_stride, int pool_padding,
+    enum tiled_matmul_type_t tiled_conv_type) {
 
-        enum tiled_matmul_type_t tiled_conv_type) {
-
-    const int krows = kernel_dim;
-    const int kcols = kernel_dim;
-    bool no_bias = false;
-    if (bias == NULL) {
-        bias = (acc_t*)1;
-        no_bias = true;
-    }
-
-    bool no_pool = pool_stride == 0;
-    if (no_pool) {
-        pool_size = 1;
-        pool_stride = 1;
-        pool_padding = 0;
-    }
-
-#ifdef GEMMINI_ASSERTIONS
-    {
-        // Check that data will fit in scratchpad
-        const int spad_rows_weight = tiled_conv_total_spad_rows(false, true,
-            stride, batches, porows, pocols, 1, kcols, kcols, 1, pool_size, pool_stride);
-        const int spad_rows_input = tiled_conv_total_spad_rows(false, false,
-            stride, batches, porows, pocols, 1, kcols, kcols, 1, pool_size, pool_stride);
-        const int acc_rows = tiled_conv_total_spad_rows(true, false,
-            stride, batches, porows, pocols, 1, kcols, kcols, 1, pool_size, pool_stride);
-
-	const int weight_bank = 1;
-
-        if (spad_rows_weight > BANK_ROWS * weight_bank) {
-            printf("not enough scratchpad space to store weights\n");
-            exit(1);
-        }
-        if (spad_rows_input > BANK_ROWS*(BANK_NUM - weight_bank)) {
-            printf("not enough scratchpad space to store inputs\n");
-            exit(1);
-        }
-        if (acc_rows > ACC_ROWS) {
-            printf("not enough accumulator space to store outputs\n");
-            exit(1);
-        }
-    }
-#endif
-
-    const int pool_out_dim = (out_dim + 2*pool_padding - pool_size) / pool_stride + 1;
-    if (no_pool) {
-        gemmini_config_st(out_channels * sizeof(elem_t));
-    }
-       for (int b = 0; b < batch_size; b += batches) {
-     	    for (int porow = 0; porow < pool_out_dim; porow += porows) {
-            	const int orow = porow * pool_stride - pool_padding;
-            	for (int pocol = 0; pocol < pool_out_dim; pocol += pocols) {
-		    for(int poch = 0; poch < out_channels; poch += 1){
-			int kch = poch;
-		        bool mvin_weight = true;
-                        const int ocol = pocol * pool_stride - pool_padding;
-                        const int orow_floored = orow < 0 ? 0 : orow;
-                        const int irow = orow_floored * stride - padding;
-                        const int ocol_floored = ocol < 0 ? 0 : ocol;
-                        const int icol = ocol_floored * stride - padding;
-
-                            //for (int kch = 0; kch < in_channels; kch += 1) {
-                                elem_t * out = output + (b*pool_out_dim*pool_out_dim + porow*pool_out_dim + pocol) * out_channels + poch;
-
-                                const acc_t * bias_ = bias + poch;
-                                const int batches_ = batch_size - b > batches ? batches : batch_size - b;
-                                const int porows_ = pool_out_dim - porow > porows ? porows : pool_out_dim - porow;
-                                const int pocols_ = pool_out_dim - pocol > pocols ? pocols : pool_out_dim - pocol;
-                                const int ocols_ = pocols_ * pool_stride + pool_size - 1;
-                                const int orows_ = porows_ * pool_stride + pool_size - 1;
-
-                                const int plpad = ocol < 0 ? -ocol : 0;
-                                const int prpad = ocol + ocols_ > out_dim ? ocol + ocols_ - out_dim : 0;
-                                const int pupad = orow < 0 ? -orow : 0;
-                                const int pdpad = orow + orows_ > out_dim ? orow + orows_ - out_dim : 0;
-
-				const int icols_ = (ocols_ - 1 - plpad - prpad) * stride + kcols;//+ kcols_;
-                                const int irows_ = (orows_ - 1 - pupad - pdpad) * stride + kcols;//krows_;
-
-
-                                const int lpad = icol < 0 ? -icol : 0;
-                                const int rpad = icol + icols_ > in_dim ? icol + icols_ - in_dim : 0;
-                                const int upad = irow < 0 ? -irow : 0;
-                                const int dpad = irow + irows_ > in_dim ? irow + irows_ - in_dim : 0;
-
-                                // printf("upad: %d\n", upad);
-                                // printf("dpad: %d\n", dpad);
-                                // printf("lpad: %d\n", lpad);
-                                // printf("rpad: %d\n", rpad);
-                                // printf("pupad: %d\n", pupad);
-                                // printf("pdpad: %d\n", pdpad);
-                                // printf("plpad: %d\n", plpad);
-                                // printf("prpad: %d\n", prpad);
-
-                                sp_tiled_conv_dw(
-                                    batch_size, in_dim, in_channels,
-                                    out_channels, out_dim, pool_out_dim,
-
-                                    stride, padding, kernel_dim,
-
-                                    pool_size, pool_stride, pool_padding,
-
-                                    batches_,
-                                    porows_, pocols_,// pochs_,
-
-				    lpad, rpad, upad, dpad,
-                                    plpad, prpad, pupad, pdpad,
-
-                                    input + (b*in_dim*in_dim + (irow+upad)*in_dim + (icol+lpad)) * in_channels + kch,
-                                    //weights + (krow*kernel_dim*in_channels + kcol*in_channels + kch) * out_channels + poch,
-			     	    weights + poch,
-                                    out,
-                                    bias_,
-
-                                    act, scale, relu6_shift,
-                                    no_bias, no_pool, mvin_weight);
-                            }
-                        }
-                    }
-
-    }
-}
-
-static void tiled_conv_first(
-        int batch_size, int in_dim, int in_channels,
-        int out_channels, int out_dim,
-        int stride, int padding,
-
-        int batches,
-        int porows, int pocols, int pochs,
-	int kcols, int kchs,
-
-        elem_t * input,
-        elem_t * weights,
-        acc_t * bias,
-        elem_t * output,
-
-        int act, acc_scale_t scale, size_t relu6_shift,
-        int pool_size, int pool_stride, int pool_padding,
-
-	enum tiled_matmul_type_t tiled_conv_type,
-	int weight_bank) {
-
-
-    if (tiled_conv_type == CPU) {
-      if (pool_size == 1 && pool_stride == 1 && pool_padding == 0) {
-        pool_stride = 0;
-      }
-
-      conv_cpu(
-        batch_size, in_dim, in_channels,
-        out_channels, out_dim,
-        stride, 1, 1, padding, kcols,//kernel_dim,
-        false, false, false, false, false,
-        input, weights, bias, output,
-        act, scale, relu6_shift,
-        pool_size, pool_stride, pool_padding);
-      return;
-    } else if (tiled_conv_type == OS) {
-      printf("Gemmini convs do not currently support OS\n");
-      exit(1);
-    }
-
-    bool no_bias = false;
-    if (bias == NULL) {
-        bias = (acc_t*)1;
-        no_bias = true;
-    }
-
-    bool no_1d = pool_stride == 0 && pool_size == 0;
-    bool no_pool = pool_stride == 0;
-    if (no_pool) {
-        pool_size = 1;
-        pool_stride = 1;
-        pool_padding = 0;
-    }
-
-//    printf("no_1d: %d, no_pool: %d, pool_size: %d, pool_stride: %d \n", no_1d, no_pool, pool_size, pool_stride);
-
-#ifdef GEMMINI_ASSERTIONS
-    {
-        // Check that data will fit in scratchpad
-        const int spad_rows_weight = tiled_conv_total_spad_rows(false, true,
-            stride, batches, porows, pocols, pochs, kcols, kcols, kchs, pool_size, pool_stride);
-        const int spad_rows_input = tiled_conv_total_spad_rows(false, false,
-            stride, batches, porows, pocols, pochs, kcols, kcols, kchs, pool_size, pool_stride);
-        const int acc_rows = tiled_conv_total_spad_rows(true, false,
-            stride, batches, porows, pocols, pochs, kcols, kcols, kchs, pool_size, pool_stride);
-
-        // printf("spad_rows: %d\n", spad_rows);
-        // printf("acc_rows: %d\n", acc_rows);
-        // exit(1);
-
-        if (spad_rows_weight > weight_bank*BANK_ROWS) {
-            printf("not enough scratchpad space to store weights\n");
-            exit(1);
-        }
-        if (spad_rows_input > BANK_ROWS*(BANK_NUM - weight_bank)) {
-            printf("not enough scratchpad space to store inputs\n");
-            exit(1);
-        }
-        if (acc_rows > ACC_ROWS) {
-            printf("not enough accumulator space to store outputs\n");
-            exit(1);
-        }
-
-    }
-#endif
-
-    const int pool_out_dim = (out_dim + 2*pool_padding - pool_size) / pool_stride + 1;
-
-    if (no_pool && no_1d) {
-        gemmini_config_st(out_channels * sizeof(elem_t));
-    }
-    int pmax = 0;
-    for(int porow = 0; porow < pool_out_dim; porow += porows)
-	pmax = porow;
-    bool mvin_weight = false;
-
-    for (int b = 0; b < batch_size; b += batches) {
-        for (int porow = 0; porow < pool_out_dim; porow += porows) {
-            const int orow = porow * pool_stride - pool_padding;
-
-            for (int pocol = 0; pocol < pool_out_dim; pocol += pocols) {
-		if(pocol == 0 || porow == 0 || pocol == pmax || porow == pmax){ //when there is padding
-                const int ocol = pocol * pool_stride - pool_padding;
-                for (int poch = 0; poch < out_channels; poch += pochs) {
-			if(pocol == 0 && porow == 0 && b == 0 && poch == 0) mvin_weight = true;
-			else mvin_weight = false;
-
-	                const int orow_floored = orow < 0 ? 0 : orow;
-                        const int irow = orow_floored * stride - padding;//+ krow - padding;
-                        const int ocol_floored = ocol < 0 ? 0 : ocol;
-                        const int icol = ocol_floored * stride - padding; //+ kcol - padding;
-//			    printf("icol: %d, ocols: %d, ocol: %d, ocol_floored: %d, kcol: %d \n", icol, ocols, ocol, ocol_floored, kcol);
-
-                            //for (int kch = 0; kch < in_channels; kch += kchs) {
-                        elem_t * out = output + (b*pool_out_dim*pool_out_dim + porow*pool_out_dim + pocol) * out_channels + poch;
-
-                        acc_t * bias_ = bias + poch;
-
-                        const int batches_ = batch_size - b > batches ? batches : batch_size - b;
-                        const int porows_ = pool_out_dim - porow > porows ? porows : pool_out_dim - porow;
-                        const int pocols_ = pool_out_dim - pocol > pocols ? pocols : pool_out_dim - pocol;
-                        const int pochs_ = out_channels - poch > pochs ? pochs : out_channels - poch;
-			const int kchs_ = in_channels;
-
-                                const int ocols_ = pocols_ * pool_stride + pool_size - 1;
-                                const int orows_ = porows_ * pool_stride + pool_size - 1;
-
-                                const int plpad = ocol < 0 ? -ocol : 0;
-                                const int prpad = ocol + ocols_ > out_dim ? ocol + ocols_ - out_dim : 0;
-                                const int pupad = orow < 0 ? -orow : 0;
-                                const int pdpad = orow + orows_ > out_dim ? orow + orows_ - out_dim : 0;
-
-        			const int icols_ = (ocols_ - 1 - plpad - prpad) * stride + kcols;//+ kcols_;
-                                const int irows_ = (orows_ - 1 - pupad - pdpad) * stride + kcols;//krows_;
-
-                                const int lpad = icol < 0 ? -icol : 0;
-                                const int rpad = icol + icols_ > in_dim ? icol + icols_ - in_dim : 0;
-                                const int upad = irow < 0 ? -irow : 0;
-                                const int dpad = irow + irows_ > in_dim ? irow + irows_ - in_dim : 0;
-
-                               sp_tiled_conv_ws_original_first(
-                                    batch_size, in_dim, in_channels,
-                                    out_channels, out_dim, pool_out_dim,
-
-                                    stride, padding, kcols,
-
-                                    pool_size, pool_stride, pool_padding,
-
-                                    batches_,
-                                    porows_, pocols_, pochs_,
-			            kcols, kchs_,
-
-                                    lpad, rpad, upad, dpad,
-                                    plpad, prpad, pupad, pdpad,
-
-                                    input + (b*in_dim*in_dim + (irow+upad)*in_dim + (icol+lpad)) * in_channels,// + kch,
-				    weights + poch,
-		 		    //weights + (krow*kernel_dim*in_channels + kcol*in_channels + kch) * out_channels + poch,
-                                    out,
-                                    bias_,
-
-                                    act, scale, relu6_shift,
-                                    no_bias, no_pool, mvin_weight,
-                                    weight_bank);
-
-                           }
-                        }
-                    }
-	       }
-    }
-
-    for (int b = 0; b < batch_size; b += batches) {
-        for (int porow = porows; porow < pmax; porow += porows) {
-            const int orow = porow * pool_stride - pool_padding;
-
-            for (int pocol = pocols; pocol < pmax; pocol += pocols) {
-                const int ocol = pocol * pool_stride - pool_padding;
-
-                for (int poch = 0; poch < out_channels; poch += pochs) {
-			if(poch == 0 && pocol == pocols && porow == porows && b == 0) mvin_weight = true;
-			else mvin_weight = false;
-	                const int orow_floored = orow < 0 ? 0 : orow;
-                        const int irow = orow_floored * stride - padding;//+ krow - padding;
-                        const int ocol_floored = ocol < 0 ? 0 : ocol;
-                        const int icol = ocol_floored * stride - padding; //+ kcol - padding;
-                               elem_t * out = output + (b*pool_out_dim*pool_out_dim + porow*pool_out_dim + pocol) * out_channels + poch;
-
-                                acc_t * bias_ = bias + poch;
-
-
-                                const int batches_ = batch_size - b > batches ? batches : batch_size - b;
-                                const int porows_ = pool_out_dim - porow > porows ? porows : pool_out_dim - porow;
-                                const int pocols_ = pool_out_dim - pocol > pocols ? pocols : pool_out_dim - pocol;
-                                const int pochs_ = out_channels - poch > pochs ? pochs : out_channels - poch;
-				const int kchs_ = in_channels;
-
-                                const int ocols_ = pocols_ * pool_stride + pool_size - 1;
-                                const int orows_ = porows_ * pool_stride + pool_size - 1;
-
-                                const int plpad = ocol < 0 ? -ocol : 0;
-                                const int prpad = ocol + ocols_ > out_dim ? ocol + ocols_ - out_dim : 0;
-                                const int pupad = orow < 0 ? -orow : 0;
-                                const int pdpad = orow + orows_ > out_dim ? orow + orows_ - out_dim : 0;
-
-       				const int icols_ = (ocols_ - 1 - plpad - prpad) * stride + kcols;//+ kcols_;
-                                const int irows_ = (orows_ - 1 - pupad - pdpad) * stride + kcols;//krows_;
-
-                               sp_tiled_conv_first(
-                                    batch_size, in_dim, in_channels,
-                                    out_channels, out_dim, pool_out_dim,
-
-                                    stride, padding,
-
-                                    pool_size, pool_stride, pool_padding,
-
-                                    batches_,
-                                    porows_, pocols_, pochs_,
-			            kcols, kchs_,
-
-                                    plpad, prpad, pupad, pdpad,
-
-                                    input + (b*in_dim*in_dim + (irow)*in_dim + (icol)) * in_channels,// + kch,
-				    weights + poch,
-		 		    //weights + (krow*kernel_dim*in_channels + kcol*in_channels + kch) * out_channels + poch,
-                                    out,
-                                    bias_,
-
-                                    act, scale, relu6_shift,
-                                    no_bias, no_pool, mvin_weight,
-                                    weight_bank);
-	                           }
-                        }
-                    }
-	     //  }
-    }
-}
-
-
-static void sp_tiled_conv_ws(
-        int batch_size, int in_dim, int in_channels,
-        int out_channels, int out_dim, int pool_out_dim,
-
-        int stride, int padding, //int kernel_dim,
-
-        int pool_size, int pool_stride, int pool_padding,
-
-        int batches,
-        int porows, int pocols, int pochs,
-	int krows, int kchs,
-
-        int lpad, int rpad, int upad, int dpad,
-        int plpad, int prpad, int pupad, int pdpad,
-
-        const elem_t * input,
-	uint32_t B_sp_addr_start,
-        //elem_t * weights,
-        elem_t * output,
-        const acc_t * bias,
-
-	int act, acc_scale_t scale, int relu6_shift,
-        bool no_bias, bool no_pool,
-	int weight_bank) {
-
-    const int orows = porows * pool_stride + pool_size - 1 - pupad - pdpad;
-    const int ocols = pocols * pool_stride + pool_size - 1 - plpad - prpad;
-    const int ochs = pochs;
-
-    // Calculate image dimensions
-    const int irows = (orows - 1) * stride + krows;
-    const int icols = (ocols - 1) * stride + krows;//kcols;
-    const int irows_unpadded = irows - upad - dpad;
-    const int icols_unpadded = icols - lpad - rpad;
-    const int ichs = kchs;
-    int kdims = krows*krows;
-
-    int double_bank = weight_bank > 1 ? 1 : 0;
-    int triple_bank = weight_bank > 2 ? 1 : 0;
-	const int odims = ocols*orows;
-//	const int im2col_width = kdims*kchs;
-	const int row_left = odims%DIM;
-	const int row_turn = row_left == 0 ? odims/DIM - 1 : odims/DIM;
-//	const int turn = im2col_width%DIM == 0 ? im2col_width/DIM : im2col_width/DIM + 1;
-	gemmini_extended2_config_ex(WEIGHT_STATIONARY, act, 0, scale, relu6_shift, 1, false, false, ocols, row_turn, krows, stride, kchs, row_left, kdims, double_bank, triple_bank); //if want 2 banks for weight, last is 1
-
-    int idims = irows*icols;
-    int bidims = batches*idims;
-   if(no_pool){
-	gemmini_config_st(out_channels*sizeof(elem_t));
-   }
-   else{
-	   gemmini_extended_config_st(out_channels * sizeof(elem_t), pool_stride, pool_size, pool_out_dim, porows, pocols, orows, ocols, pupad, plpad);
-   }
-    const uint32_t A_sp_addr_start = 0;
-    const uint32_t D_sp_addr_start = 1 << (ADDR_LEN - 1);
-    const uint32_t C_sp_addr_start = 3 << (ADDR_LEN - 2);
-
-     //printf("mvin bias\n");
-    // mvin bias
-
-    if (!no_bias && bias != NULL) {
-        // TODO we probably don't need quite this many nested loops for this part
-        gemmini_config_ld(0);
-        for (int b = 0; b < batches; b++)
-          for (int och = 0; och < ochs; och += DIM) {
-               const int J = ochs - och > DIM ? DIM : ochs - och;
-               const uint32_t D_sp_addr = D_sp_addr_start + (och / DIM) * batches * odims + b * odims;// + odim;
-	        for(int odim = 0; odim < odims; odim += DIM){
-                   // const int I = ocols - ocol > DIM ? DIM : ocols - ocol;
-		    const int I = odims - odim > DIM ? DIM : odims - odim;
-                        gemmini_extended_mvin(bias + och,
-                                D_sp_addr+odim,
-                                J, I);
-                    }
-                }
-    }
-
-    // mvin input
-    // printf("mvin inputs\n");
-    gemmini_config_ld(in_channels * sizeof(elem_t));
-    static elem_t zeros[MAX_BYTES / sizeof(elem_t)] = {0};
-//    gemmini_fence(); // TODO fix ROB to get rid of this requirement
-    for (int b = 0; b < batches; b++) {
-        for (int irow = -upad; irow < irows_unpadded + dpad; irow++) {
-            const int irow_padded = irow + upad;
-
-            for (int icol = -lpad; icol < icols_unpadded + rpad;) {
-                int I = icols_unpadded - icol > DIM ? DIM : icols_unpadded - icol;
-                const elem_t * in = input + (b*in_dim*in_dim + irow*in_dim + icol) * in_channels;// + ich;
-
-                if (icol < 0) {
-                    I = -icol > DIM ? DIM : -icol;
-                } else if (icol >= icols_unpadded) {
-                    I = icols_unpadded + rpad - icol > DIM ? DIM : icols_unpadded + rpad - icol;
-                }
-                const bool is_zeros = irow < 0 || irow >= irows_unpadded || icol < 0 || icol >= icols_unpadded;
-                const int icol_padded = icol + lpad;
-		const uint32_t A_sp_addr = A_sp_addr_start + b * idims + irow_padded * icols + icol_padded;
-		if(is_zeros){
-	           	   gemmini_config_ld(0);
-			for (int ich = 0; ich < ichs; ich += DIM) {
-                    	   const int K = ichs - ich > DIM ? DIM : ichs - ich;
-                           in = &zeros[0];
-                           gemmini_extended_mvin(in+ich,
-                            A_sp_addr + (ich/DIM)*bidims,
-                            K, I);
-                    }
-		   gemmini_config_ld(in_channels * sizeof(elem_t));
-
-
-		}else{
-                   for (int ich = 0; ich < ichs; ich += DIM) {
-                       const int K = ichs - ich > DIM ? DIM : ichs - ich;
-                       gemmini_extended_mvin(in+ich,
-                            A_sp_addr + (ich/DIM)*bidims,
-                            K, I);
-
-                    }
-		}
-                icol += I;
-            }
-        }
-    }
-
-//printf("matmul \n");
-   for (int b = 0; b < batches; b++){
-        for (int och = 0; och < ochs; och += DIM) {
-            const int J = ochs - och > DIM ? DIM : ochs - och;
-     	    const uint32_t C_sp_addr_outer = C_sp_addr_start + (och / DIM) * batches * odims + b * odims;// + odim;
-
-	    for (int kch = 0; kch < kchs; kch += DIM) {
-	        const int K = kchs - kch > DIM ? DIM : kchs - kch;
-		const uint32_t A_sp_addr = A_sp_addr_start + (kch / DIM)*batches*idims + b*idims;
-		const int kkdims = K*kdims;
-		const uint32_t B_sp_addr = B_sp_addr_start + (och / DIM) * kdims * kchs + kch*kdims;
-
-            	for(int odim = 0; odim < odims; odim += DIM){ //both dimension at the same time
-			const int I = odims - odim > DIM ? DIM : odims - odim;
-			const uint32_t C_sp_addr = C_sp_addr_outer + odim;
-
-			for(int kkdim = 0; kkdim < kkdims; kkdim += K){
-                                gemmini_extended_preload(B_sp_addr + kkdim, C_sp_addr,
-                                        J, K, J, I);
-                                gemmini_extended_compute_preloaded(A_sp_addr, GARBAGE_ADDR, K, I, J, I);
-			}
-                   }
-                }
-   	}
-     }
-
-   //gemmini_fence();
-//printf("mvout\n");
-  if(output!=NULL){
-     if (no_pool) {
-            for (int b = 0; b < batches; b++)
-                for (int orow = 0; orow < orows; orow++)
-                    for (int ocol = 0; ocol < ocols; ocol += DIM) {
-                        const int I = ocols - ocol > DIM ? DIM : ocols - ocol;
-
-                        for (int och = 0; och < ochs; och += DIM) {
-                            const int J = ochs - och > DIM ? DIM : ochs - och;
-                            const uint32_t C_sp_addr = C_sp_addr_start + (och / DIM) * batches * orows * ocols + b * orows * ocols + orow * ocols + ocol;
-
-                            gemmini_extended_mvout(output + (b*out_dim*out_dim + orow*out_dim + ocol) * out_channels + och,
-                                    C_sp_addr,
-                                    J, I);
-                        }
-
-                    }
-
-      } else {
-            gemmini_fence(); // TODO remove this when the ROB can accurately handle these
-            for (int b = 0; b < batches; b++) {
-                for (int poch = 0; poch < pochs; poch += DIM) {
-                    const int channels = poch + DIM >= pochs ? pochs - poch : DIM;
-                    elem_t * pout = output + (b * pool_out_dim * pool_out_dim)*out_channels + poch;
-                    const uint32_t C_sp_addr = C_sp_addr_start + (poch / DIM) * batches * orows * ocols + b * orows * ocols;
-                    gemmini_extended_mvout(pout,
-                            C_sp_addr,
-                            channels, 0);
-                }
-            }
-            gemmini_fence(); // TODO remove this when the ROB can accurately handle these
-      }
-   }
-//attempts to merge mvin-matmul-mvout loops
-//ROB problem: some have wrong results
-/*
-   gemmini_config_ld(0);
-   for (int b = 0; b < batches; b++){
-        for (int och = 0; och < ochs; och += DIM) {
-            const int J = ochs - och > DIM ? DIM : ochs - och;
-            const uint32_t D_sp_addr = D_sp_addr_start + (och / DIM) * batches * odims + b * odims;// + odim;
-      	    const uint32_t C_sp_addr_outer = C_sp_addr_start + (och / DIM) * batches * odims + b * odims;// + odim;
-
-	    for (int kch = 0; kch < kchs; kch += DIM) {
-	        const int K = kchs - kch > DIM ? DIM : kchs - kch;
-		const uint32_t A_sp_addr = A_sp_addr_start + (kch / DIM)*batches*idims + b*idims;
-		const int kkdims = K*kdims;
-		const uint32_t B_sp_addr = B_sp_addr_start + (och / DIM) * kdims * kchs + kch*kdims;
-
-            	for(int odim = 0; odim < odims; odim += DIM){ //both dimension at the same time
-			const int I = odims - odim > DIM ? DIM : odims - odim;
-			if(kch == 0)
-                        	gemmini_extended_mvin(bias + och,
-                                	D_sp_addr+odim,
-                                	J, I);
-			const uint32_t C_sp_addr = C_sp_addr_outer + odim;
-
-			for(int kkdim = 0; kkdim < kkdims; kkdim += K){
-                                gemmini_extended_preload(B_sp_addr + kkdim, C_sp_addr,
-                                        J, K, J, I);
-                                gemmini_extended_compute_preloaded(A_sp_addr, GARBAGE_ADDR, K, I, J, I);
-			}
-                   }
-                }
-
- 	    if(output!=NULL){
-		//const uint32_t C_sp_addr = C_sp_addr_start + (och / DIM) * batches * odims + b * odims;
-		if(no_pool){
-  		   gemmini_extended_mvout(output + (b * out_dim * out_dim)*out_channels + och, C_sp_addr_outer, J, 0);
-		}
-		else{
-		   gemmini_extended_mvout(output + (b * pool_out_dim * pool_out_dim) * out_channels + och, C_sp_addr_outer, J, 0);
-		}
-	   }
-
-   	}
-     }
-           if (no_pool) {
-            for (int b = 0; b < batches; b++)
-                for (int orow = 0; orow < orows; orow++)
-                    for (int ocol = 0; ocol < ocols; ocol += DIM) {
-                        const int I = ocols - ocol > DIM ? DIM : ocols - ocol;
-
-                        for (int och = 0; och < ochs; och += DIM) {
-                            const int J = ochs - och > DIM ? DIM : ochs - och;
-//			int J = 1; int och = 0;
-                            const uint32_t C_sp_addr = C_sp_addr_start + (och / DIM) * batches * orows * ocols + b * orows * ocols + orow * ocols + ocol;
-
-                            gemmini_extended_mvout(output + (b*out_dim*out_dim + orow*out_dim + ocol) * out_channels + och,
-                                    C_sp_addr,
-                                    J, I);
-                        }
-
-                    }
-	   } else {
-//		   printf("pool \n");
-              gemmini_extended_config_st(out_channels * sizeof(elem_t), pool_stride, pool_size, pool_out_dim, porows, pocols, orows, ocols, pupad, plpad);
-//             gemmini_fence(); // TODO remove this when the ROB can accurately handle these
-            for (int b = 0; b < batches; b++) {
-                for (int poch = 0; poch < pochs; poch += DIM) {
-                    const int channels = poch + DIM >= pochs ? pochs - poch : DIM;
-                    elem_t * pout = output + (b * pool_out_dim * pool_out_dim)*out_channels + poch;
-                    const uint32_t C_sp_addr = C_sp_addr_start + (poch / DIM) * batches * orows * ocols + b * orows * ocols;
-                    gemmini_extended_mvout(pout,
-                            C_sp_addr,
-                            channels, 0);
-                }
-            }
-//            gemmini_fence();
-        }
-*/
-/*
-    // mvout output
-   if (output != NULL) {
-		gemmini_extended_config_st(out_channels * sizeof(elem_t), 0, 1, out_dim, 0, 0, orows, ocols, 0, 0);
-		for(int b = 0; b < batches; b++)
-			for(int och = 0; och < ochs; och += DIM){
-				const int J = ochs - och > DIM ? DIM : ochs - och;
-				const uint32_t C_sp_addr = C_sp_addr_start + (och / DIM) * batches * odims + b * odims;
-				gemmini_extended_mvout(output + (b * out_dim * out_dim)*out_channels + och, C_sp_addr, J, 0);
-			}
-		//}
-
-*/
-//            gemmini_fence();
-//    	uint64_t end_mvout = read_cyclesh();
-//	printf("mvout cycles: %d \n", end_mvout - start_mvout);
-
-}
-
-//outer loop without weight mvin (due to large channel size)
-static void tiled_conv_original(
-        int batch_size, int in_dim, int in_channels,
-        int out_channels, int out_dim,
-        int stride, int padding, int kernel_dim,
-
-        int batches,
-        int porows, int pocols, int pochs,
-	int kcols, int kchs,
-
-        const elem_t * input,
-        const elem_t * weights,
-        const acc_t * bias,
-        elem_t * output,
-
-        int act, acc_scale_t scale, size_t relu6_shift,
-        int pool_size, int pool_stride, int pool_padding,
-
-	enum tiled_matmul_type_t tiled_conv_type,
-	int weight_bank) {
-
-
-    if (tiled_conv_type == CPU) {
-      if (pool_size == 1 && pool_stride == 1 && pool_padding == 0) {
-        pool_stride = 0;
-      }
-
-      conv_cpu(
-        batch_size, in_dim, in_channels,
-        out_channels, out_dim,
-        stride, 1, 1, padding, kernel_dim,
-        false, false, false, false, false,
-        input, weights, bias, output,
-        act, scale, relu6_shift,
-        pool_size, pool_stride, pool_padding);
-      return;
-    } else if (tiled_conv_type == OS) {
-      printf("Gemmini convs do not currently support OS\n");
-      exit(1);
-    }
-
-    bool no_bias = false;
-    if (bias == NULL) {
-        bias = (acc_t*)1;
-        no_bias = true;
-    }
-
-//    bool no_1d = pool_stride == 0 && pool_size == 0;
-    bool no_pool = pool_stride == 0;
-    if (no_pool) {
-        pool_size = 1;
-        pool_stride = 1;
-        pool_padding = 0;
-    }
-#ifdef GEMMINI_ASSERTIONS
-    {
-        // Check that data will fit in scratchpad
-        const int spad_rows_weight = tiled_conv_total_spad_rows(false, true,
-            stride, batches, porows, pocols, pochs, kcols, kcols, kchs, pool_size, pool_stride);
-        const int spad_rows_input = tiled_conv_total_spad_rows(false, false,
-            stride, batches, porows, pocols, pochs, kcols, kcols, kchs, pool_size, pool_stride);
-        const int acc_rows = tiled_conv_total_spad_rows(true, false,
-            stride, batches, porows, pocols, pochs, kcols, kcols, kchs, pool_size, pool_stride);
-
-        if (spad_rows_weight > weight_bank*BANK_ROWS) {
-            printf("not enough scratchpad space to store weights\n");
-            exit(1);
-        }
-        if (spad_rows_input > BANK_ROWS*(BANK_NUM - weight_bank)) {
-            printf("not enough scratchpad space to store inputs\n");
-            exit(1);
-        }
-        if (acc_rows > ACC_ROWS) {
-            printf("not enough accumulator space to store outputs\n");
-            exit(1);
-        }
-        if (kernel_dim <= padding) {
-            printf("kernel_dim must be larger than padding\n");
-            exit(1);
-        }
-    }
-#endif
-
-    const int pool_out_dim = (out_dim + 2*pool_padding - pool_size) / pool_stride + 1;
-
-    if (no_pool) {
-        gemmini_config_st(out_channels * sizeof(elem_t));
-    }
-
-    for (int b = 0; b < batch_size; b += batches) {
-        for (int porow = 0; porow < pool_out_dim; porow += porows) {
-            const int orow = porow * pool_stride - pool_padding;
-
-            for (int pocol = 0; pocol < pool_out_dim; pocol += pocols) {
-                const int ocol = pocol * pool_stride - pool_padding;
-
-                for (int poch = 0; poch < out_channels; poch += pochs) {
-	                const int orow_floored = orow < 0 ? 0 : orow;
-                        const int irow = orow_floored * stride - padding;//+ krow - padding;
-                        const int ocol_floored = ocol < 0 ? 0 : ocol;
-                        const int icol = ocol_floored * stride - padding; //+ kcol - padding;
-//			    printf("icol: %d, ocols: %d, ocol: %d, ocol_floored: %d, kcol: %d \n", icol, ocols, ocol, ocol_floored, kcol);
-
-                            for (int kch = 0; kch < in_channels; kch += kchs) {
-                                elem_t * out = output + (b*pool_out_dim*pool_out_dim + porow*pool_out_dim + pocol) * out_channels + poch;
-                                if (kch + kchs < in_channels) {
-                                    out = NULL;
-                                }
-                                const acc_t * bias_ = bias + poch;
-                                if (kch > 0) {
-                                    bias_ = NULL;
-                                }
-
-                                const int batches_ = batch_size - b > batches ? batches : batch_size - b;
-                                const int porows_ = pool_out_dim - porow > porows ? porows : pool_out_dim - porow;
-                                const int pocols_ = pool_out_dim - pocol > pocols ? pocols : pool_out_dim - pocol;
-                                const int pochs_ = out_channels - poch > pochs ? pochs : out_channels - poch;
-			        const int kchs_ = in_channels - kch > kchs ? kchs : in_channels - kch;
-
-                                const int ocols_ = pocols_ * pool_stride + pool_size - 1;
-                                const int orows_ = porows_ * pool_stride + pool_size - 1;
-
-                                const int plpad = ocol < 0 ? -ocol : 0;
-                                const int prpad = ocol + ocols_ > out_dim ? ocol + ocols_ - out_dim : 0;
-                                const int pupad = orow < 0 ? -orow : 0;
-                                const int pdpad = orow + orows_ > out_dim ? orow + orows_ - out_dim : 0;
-
-				const int icols_ = (ocols_ - 1 - plpad - prpad) * stride + kcols;//+ kcols_;
-                                const int irows_ = (orows_ - 1 - pupad - pdpad) * stride + kcols;//krows_;
-
-                                const int lpad = icol < 0 ? -icol : 0;
-                                const int rpad = icol + icols_ > in_dim ? icol + icols_ - in_dim : 0;
-                                const int upad = irow < 0 ? -irow : 0;
-                                const int dpad = irow + irows_ > in_dim ? irow + irows_ - in_dim : 0;
-
-				if(kernel_dim != 1)
-                                  sp_tiled_conv_ws_original(
-                                    batch_size, in_dim, in_channels,
-                                    out_channels, out_dim, pool_out_dim,
-
-                                    stride, padding, kernel_dim,
-
-                                    pool_size, pool_stride, pool_padding,
-
-                                    batches_,
-                                    porows_, pocols_, pochs_,
-			            kcols, kchs_,
-
-                                    lpad, rpad, upad, dpad,
-                                    plpad, prpad, pupad, pdpad,
-
-                                    input + (b*in_dim*in_dim + (irow+upad)*in_dim + (icol+lpad)) * in_channels + kch,
-				    weights + kch * out_channels + poch,
-		 		    //weights + (krow*kernel_dim*in_channels + kcol*in_channels + kch) * out_channels + poch,
-                                    out,
-                                    bias_,
-
-                                    act, scale, relu6_shift,
-                                    no_bias, no_pool,
-                                    weight_bank);
-
-				else //downsampling layer
-                                  sp_tiled_conv_ds(
-                                    batch_size, in_dim, in_channels,
-                                    out_channels, out_dim, pool_out_dim,
-
-                                    stride, pool_size, pool_stride, pool_padding,
-
-                                    batches_,
-                                    porows_, pocols_, pochs_,
-			            kchs_,
-
-                                    lpad, rpad, upad, dpad,
-                                    plpad, prpad, pupad, pdpad,
-
-                                    input + (b*in_dim*in_dim + (irow+upad)*in_dim + (icol+lpad)) * in_channels + kch,
-				    0,
-				    weights + kch * out_channels + poch,
-		 		    //weights + (krow*kernel_dim*in_channels + kcol*in_channels + kch) * out_channels + poch,
-                                    out,
-                                    bias_,
-
-                                    act, scale, relu6_shift,
-                                    no_bias, no_pool,
-                                    weight_bank);
-                           }
-                        }
-                    }
-	       }
-    }
-}
-
-
-static void tiled_conv(
-        int batch_size, int in_dim, int in_channels,
-        int out_channels, int out_dim,
-        int stride, int padding, int kernel_dim,
-
-        int batches,
-        int porows, int pocols, int pochs,
-        int krows, int kcols, int kchs,
-
-        const elem_t * input,
-        const elem_t * weights,
-        const acc_t * bias,
-        elem_t * output,
-
-        int act, acc_scale_t scale, size_t relu6_shift,
-        int pool_size, int pool_stride, int pool_padding,
-
-        int weight_bank, enum tiled_matmul_type_t tiled_conv_type) {
-
-    if (tiled_conv_type == CPU) {
-      if (pool_size == 1 && pool_stride == 1 && pool_padding == 0) {
-        pool_stride = 0;
-      }
-
-      conv_cpu(
-        batch_size, in_dim, in_channels,
-        out_channels, out_dim,
-        stride, 1, 1, padding, kernel_dim,
-        false, false, false, false, false,
-        input, weights, bias, output,
-        act, scale, relu6_shift,
-        pool_size, pool_stride, pool_padding);
-      return;
-    } else if (tiled_conv_type == OS) {
-      printf("Gemmini convs do not currently support OS\n");
-      exit(1);
-    }
-
-    // TODO move everything below this into a tiled_conv_outer function to match the tiled_matmul function
-
-    bool no_bias = false;
-    if (bias == NULL) {
-        bias = (acc_t*)1;
-        no_bias = true;
-    }
-
-    bool no_pool = pool_stride == 0;
-    if (no_pool) {
-        pool_size = 1;
-        pool_stride = 1;
-        pool_padding = 0;
-    }
-
-
-
-#ifdef GEMMINI_ASSERTIONS
-    {
-        // Check that data will fit in scratchpad
-        const int spad_rows_weight = tiled_conv_total_spad_rows(false, true,
-            stride, batches, porows, pocols, pochs, kcols, kcols, kchs, pool_size, pool_stride);
-        const int spad_rows_input = tiled_conv_total_spad_rows(false, false,
-            stride, batches, porows, pocols, pochs, kcols, kcols, kchs, pool_size, pool_stride);
-        const int acc_rows = tiled_conv_total_spad_rows(true, false,
-            stride, batches, porows, pocols, pochs, kcols, kcols, kchs, pool_size, pool_stride);
-
-	if (spad_rows_weight > BANK_ROWS * weight_bank) {
-            printf("not enough scratchpad space to store weights\n");
-            exit(1);
-        }
-        if (spad_rows_input > BANK_ROWS*(BANK_NUM - weight_bank)) {
-            printf("not enough scratchpad space to store inputs\n");
-            exit(1);
-        }
-        if (acc_rows > ACC_ROWS) {
-            printf("not enough accumulator space to store outputs\n");
-            exit(1);
-        }
-    }
-#endif
-    int kdims = kcols*kcols;
-    const uint32_t B_sp_addr_start = (BANK_NUM - weight_bank) * BANK_ROWS;
-
-    const int pool_out_dim = (out_dim + 2*pool_padding - pool_size) / pool_stride + 1;
-
-      for (int poch = 0; poch < out_channels; poch += pochs) {
-           const int pochs_ = out_channels - poch > pochs ? pochs : out_channels - poch;
-                const acc_t * bias_ = bias + poch;
-
-		const int kchs_ = in_channels;
-		gemmini_config_ld(out_channels*sizeof(elem_t));
-		//mvin weight on the outer loop
-		//printf("mvin weight\n");
-		  for (int och = 0; och < pochs_; och += DIM) {
-        		const int J = pochs_ - och > DIM ? DIM : pochs_ - och;
-      			for (int ich = 0; ich < kchs_; ich += DIM) {
-        		    const int K = kchs_ - ich > DIM ? DIM : kchs_ - ich;
-        		    for (int krow = 0; krow < kcols; krow++){
-				const elem_t * weight = weights + poch + (krow*kcols*in_channels + ich) * out_channels + och;
-				const uint32_t B_sp_addr = B_sp_addr_start + (och / DIM) * kdims * kchs_ + ich*kdims + krow*kcols*K;// + kcol*K;
-            			for (int kcol = 0; kcol < kcols; kcol++){
-					gemmini_extended_mvin(weight + kcol*in_channels*out_channels,
-						B_sp_addr+kcol*K,
-                        			J, K);
-	    			}
-       			    }
-			}
-    		  }
-		  for (int b = 0; b < batch_size; b += batches) {
-		        for (int porow = 0; porow < pool_out_dim; porow += porows) {
-		            const int orow = porow * pool_stride - pool_padding;
-            		    for (int pocol = 0; pocol < pool_out_dim; pocol += pocols) {
-				elem_t * out = output + (b*pool_out_dim*pool_out_dim + porow*pool_out_dim + pocol) * out_channels + poch;
-		                const int ocol = pocol * pool_stride - pool_padding;
-                                const int batches_ = batch_size - b > batches ? batches : batch_size - b;
-                                const int porows_ = pool_out_dim - porow > porows ? porows : pool_out_dim - porow;
-                                const int pocols_ = pool_out_dim - pocol > pocols ? pocols : pool_out_dim - pocol;
-			        const int orow_floored = orow < 0 ? 0 : orow;
-            			const int irow = orow_floored * stride - padding;//+ krow - padding;
-            			const int ocol_floored = ocol < 0 ? 0 : ocol;
-            			const int icol = ocol_floored * stride - padding; //+ kcol - padding;
-
-                                const int ocols_ = pocols_ * pool_stride + pool_size - 1;
-                                const int orows_ = porows_ * pool_stride + pool_size - 1;
-
-                                const int plpad = ocol < 0 ? -ocol : 0;
-                                const int prpad = ocol + ocols_ > out_dim ? ocol + ocols_ - out_dim : 0;
-                                const int pupad = orow < 0 ? -orow : 0;
-                                const int pdpad = orow + orows_ > out_dim ? orow + orows_ - out_dim : 0;
-
-     				const int icols_ = (ocols_ - 1 - plpad - prpad) * stride + kcols;//+ kcols_;
-                                const int irows_ = (orows_ - 1 - pupad - pdpad) * stride + kcols;//krows_;
-
-                                const int lpad = icol < 0 ? -icol : 0;
-                                const int rpad = icol + icols_ > in_dim ? icol + icols_ - in_dim : 0;
-                                const int upad = irow < 0 ? -irow : 0;
-                                const int dpad = irow + irows_ > in_dim ? irow + irows_ - in_dim : 0;
-/*				printf("ocols_: %d \n", ocols_);
-				printf("orows_: %d \n", orows_);
-      				printf("icols_: %d \n", icols_);
-				printf("irows_: %d \n", irows_);
-				printf("kchs_: %d \n", kchs_);
-				printf("kch: %d \n", kch);
-
-                                 printf("upad: %d\n", upad);
-                                 printf("dpad: %d\n", dpad);
-                                 printf("lpad: %d\n", lpad);
-                                 printf("rpad: %d\n", rpad);
-                                 printf("pupad: %d\n", pupad);
-                                 printf("pdpad: %d\n", pdpad);
-                                 printf("plpad: %d\n", plpad);
-                                 printf("prpad: %d\n", prpad);
-*/
-			if(kcols != 1)
-                               sp_tiled_conv_ws(
-                                    batch_size, in_dim, in_channels,
-                                    out_channels, out_dim, pool_out_dim,
-
-                                    stride, padding,// kernel_dim,
-
-                                    pool_size, pool_stride, pool_padding,
-
-                                    batches_,
-                                    porows_, pocols_, pochs_,
-                                    kcols, kchs_,
-
-                                    lpad, rpad, upad, dpad,
-                                    plpad, prpad, pupad, pdpad,
-
-                                    input + (b*in_dim*in_dim + (irow+upad)*in_dim + (icol+lpad)) * in_channels,// + kch,
-				    B_sp_addr_start,
-				   // weights + kch * out_channels + poch,
-		 		    out,
-                                    bias_,
-
-                                    act, scale, relu6_shift,
-                                    no_bias, no_pool,
-                                    weight_bank);
-				else
-                               sp_tiled_conv_ds(
-                                    batch_size, in_dim, in_channels,
-                                    out_channels, out_dim, pool_out_dim,
-
-                                    stride, //padding, kernel_dim,
-
-                                    pool_size, pool_stride, pool_padding,
-
-                                    batches_,
-                                    porows_, pocols_, pochs_,
-                                    kchs_,
-
-                                    lpad, rpad, upad, dpad,
-                                    plpad, prpad, pupad, pdpad,
-
-                                    input + (b*in_dim*in_dim + (irow+upad)*in_dim + (icol+lpad)) * in_channels, //+ kch,
-                                    B_sp_addr_start,
-                                    NULL, //weights + kch * out_channels + poch,
-                                    out,
-                                    bias_,
-
-                                    act, scale, relu6_shift,
-                                    no_bias, no_pool,
-                                    weight_bank);
-
-                            }
-                        }
-                    }
-//	       }
-    }
-//	printf("mvin total cycles %d \n", mvin_cycles);
-}
-
-static void tiled_conv_auto_first(
-        int batch_size, int in_dim, int in_channels,
-        int out_channels, int out_dim,
-        int stride, int padding, int kernel_dim,
-
-        elem_t * input,
-        elem_t * weights,
-        acc_t * bias,
-        elem_t * output,
-
-        int act, acc_scale_t scale, size_t relu6_shift,
-        int pool_size, int pool_stride, int pool_padding,
-
-	enum tiled_matmul_type_t tiled_conv_type) {
-   int weight_bank = 1;
-
-   const bool no_pool = pool_stride == 0 || (pool_stride == 1 && pool_size == 1 && pool_padding == 0);
-//    const bool no_1d = pool_stride == 0 && pool_size == 0;
-    const bool no_1d =false;// no_pool; //Todo: change to 1d
-
-    if (no_pool) {
-        pool_size = 1;
-        pool_stride = 1;
-        pool_padding = 0;
-    }
-    const int pool_out_dim = (out_dim + 2*pool_padding - pool_size) / pool_stride + 1;
-
-    // int args[] = {batch_size, porows, pocols, pochs, krows, kcols, kchs};
-    int args[] = {batch_size, pool_out_dim, pool_out_dim, out_channels, in_channels};
-
-    int acc_rows = tiled_conv_total_spad_rows(true, false,
-        stride, args[0], args[1], args[2], args[3], kernel_dim, kernel_dim, args[4], pool_size, pool_stride);
-//   printf("batch: %d, out_dim: %d, out_channel: %d, in_channel: %d \n", args[0], args[1], args[3], args[4]);
-
-    int och_floor = (args[3]/DIM) + 1;
-    while(acc_rows > ACC_ROWS){ //batch output channel, output dimension affects
-		if(args[1] != 1){
-			args[1]--;
-			args[2]--;
-		}else{
-			if(args[3] >= args[0]){
-				och_floor = och_floor - 1;
-				args[3] = och_floor * DIM;
-			}
-			else args[0]--;
-		}
-	acc_rows = tiled_conv_total_spad_rows(true, false, stride, args[0], args[1], args[2], args[3], kernel_dim, kernel_dim, args[4], pool_size, pool_stride);
-    }
-//	printf("batch: %d, out_dim: %d, out_channel: %d, in_channel: %d \n", args[0], args[1], args[3], args[4]);
-
-    int spad_rows_weight = tiled_conv_total_spad_rows(false, true,
-        stride, args[0], args[1], args[2], args[3], kernel_dim, kernel_dim, args[4], pool_size, pool_stride);
-    while(spad_rows_weight > BANK_ROWS * weight_bank){ //tile weight first (allocate bank3 to weight)
-	//input channel, output channel
-	och_floor = och_floor -	1;
-	args[3] = och_floor * DIM;
-	spad_rows_weight = tiled_conv_total_spad_rows(false, true,
-        	stride, args[0], args[1], args[2], args[3], kernel_dim, kernel_dim, args[4], pool_size, pool_stride);
-    }
-
-    int batches = args[0];
-    int orows = args[1];
-    int ocols = args[2];
-    int ochs = args[3];
-    int kchs = args[4];
-
-/*
-     printf("batches = %d\n", batches);
-     printf("orows = %d\n", orows);
-     printf("ocols = %d\n", ocols);
-     printf("ochs = %d\n", ochs);
-//     printf("kcols = %d\n", kernel_dim);
-     printf("kchs = %d\n", kchs);
-*/
-
-   tiled_conv_first(
-        batch_size, in_dim, in_channels,
-        out_channels, out_dim,
-        stride, padding,// kernel_dim,
-
-        batches,
-        orows, ocols, ochs,
-	kernel_dim, kchs,
-
-        input,
-        weights,
-        bias,
-        output,
-
-        act, scale, relu6_shift,
-        no_1d ? 0 : pool_size, no_pool ? 0 : pool_stride, pool_padding,
-
-	tiled_conv_type,
-	weight_bank);
-
-
-	gemmini_fence();
-}
-
-//for mobilenet depthwise conv
-static void tiled_conv_auto_dw(
-        int batch_size, int in_dim, int in_channels,
-        int out_channels, int out_dim,
-        int stride, int padding, int kernel_dim,
-
-        elem_t * input,
-        elem_t * weights,
-        acc_t * bias,
-        elem_t * output,
-
-        int act, acc_scale_t scale, size_t relu6_shift,
-        int pool_size, int pool_stride, int pool_padding,
-
-        enum tiled_matmul_type_t tiled_conv_type) {
-
-    const bool no_pool = pool_stride == 0;
-    if (no_pool) {
-        pool_size = 1;
-        pool_stride = 1;
-        pool_padding = 0;
-    }
+    const bool no_pool = pool_stride == 0;
+    if (no_pool) {
+        pool_size = 1;
+        pool_stride = 1;
+        pool_padding = 0;
+    }
 
     const int pool_out_dim = (out_dim + 2*pool_padding - pool_size) / pool_stride + 1;
 
-    const int weight_bank = 1;//((int)(kernel_dim*kernel_dim*in_channels)/BANK_ROWS)+1;
-    // int args[] = {batch_size, porows, pocols, pochs, krows, kcols, kchs};
-    int args[] = {batch_size, pool_out_dim, pool_out_dim, 1, 1}; //out_channel, in_channel to 1
-
-    int acc_rows = tiled_conv_total_spad_rows(true, false,
-        stride, args[0], args[1], args[2], args[3], kernel_dim, kernel_dim, args[4], pool_size, pool_stride);
-//   printf("batch: %d, out_dim: %d, out_channel: %d, in_channel: %d \n", args[0], args[1], args[3], args[4]);
-
-    int och_floor = (args[3]/DIM) + 1;
-    while(acc_rows > ACC_ROWS){ //batch output channel, output dimension affects
- //tile output dimension
-		if(args[1] != 1){
-			args[1]--;
-			args[2]--;
-		}else{
-			args[0]--;
-		}
-
-	acc_rows = tiled_conv_total_spad_rows(true, false, stride, args[0], args[1], args[2], args[3], kernel_dim, kernel_dim, args[4], pool_size, pool_stride);
-    }
-
-    int batches = args[0];
-    int orows = args[1];
-    int ocols = args[2];
-    int ochs = args[3];
-    int krows = kernel_dim;//args[4];
-    int kcols = kernel_dim;//args[5];
-    int kchs = args[4];
-
-/*
-     printf("batches = %d\n", batches);
-     printf("orows = %d\n", orows);
-     printf("ocols = %d\n", ocols);
-     printf("ochs = %d\n", ochs);
-     printf("kcols = %d\n", kernel_dim);
-     printf("kchs = %d\n", kchs);
-*/
-    tiled_conv_dw(
-        batch_size, in_dim, in_channels,
-        out_channels, out_dim,
-        stride, padding, kernel_dim,
-
-        batches,
-        orows, ocols,// ochs,
-//        krows, kcols, kchs,
-
-        input,
-        weights,
-        bias,
-        output,
-
-        act, scale, relu6_shift,
-        pool_size, no_pool ? 0 : pool_stride, pool_padding,
+    // Tile convolution params
 
-        tiled_conv_type);
-}
+    // int args[] = {batch_size, porows, pocols, pochs, krows, kcols, kchs};
+    int args[] = {batch_size, pool_out_dim, pool_out_dim, 1, kernel_dim, kernel_dim, 1};
+    const int max_args[] = {batch_size, pool_out_dim, pool_out_dim, 1, kernel_dim, kernel_dim, 1};
 
-//for resnet deeper layers
-//when we need to tile input channel dimension
-static void tiled_conv_auto_original(
-        int batch_size, int in_dim, int in_channels,
-        int out_channels, int out_dim,
-        int stride, int padding, int kernel_dim,
+    const int orows_idx = 1;
+    const int ocols_idx = 2;
+    const int out_channels_idx = 3;
 
-        elem_t * input,
-        elem_t * weights,
-        acc_t * bias,
-        elem_t * output,
+    // We divide by 2 for the sake of double-buffering
+    const int max_spad_rows = (BANK_NUM*BANK_ROWS / 2);
+    const int max_acc_rows = (ACC_ROWS / 2);
 
-        int act, acc_scale_t scale, size_t relu6_shift,
-        int pool_size, int pool_stride, int pool_padding,
+    int spad_rows = tiled_conv_total_spad_rows(false,
+        stride, 1, 1, false, false, false,
+        args[0], args[1], args[2], args[3], args[4], args[5], args[6], pool_size, pool_stride);
+    int acc_rows = tiled_conv_total_spad_rows(true,
+        stride, 1, 1, false, false, false,
+        args[0], args[1], args[2], args[3], args[4], args[5], args[6], pool_size, pool_stride);
 
-	enum tiled_matmul_type_t tiled_conv_type) {
+    while (spad_rows > max_spad_rows || acc_rows > max_acc_rows) {
+        int max_val = -1;
+        int max_idx = -1;
 
-   const int weight_bank = in_channels > 500? 3 : 2;
-   const bool no_pool = pool_stride == 0 || (pool_stride == 1 && pool_size == 1 && pool_padding == 0);
-    const bool no_1d = no_pool; //Todo: change to 1d
+        for (size_t i = 0; i < sizeof(args)/sizeof(args[0]); i++) {
+            // We avoid reducing ocols when possible to keep the spatial array fully utilized
+            if (!(i == ocols_idx && args[i] <= DIM && args[orows_idx] > 1)
+                    && args[i] > max_val) {
+                max_val = args[i];
+                max_idx = i;
+            }
+        }
 
-    if (no_pool) {
-        pool_size = 1;
-        pool_stride = 1;
-        pool_padding = 0;
-    }
-    const int pool_out_dim = (out_dim + 2*pool_padding - pool_size) / pool_stride + 1;
+        if (max_idx == out_channels_idx) {
+            // For input and output channels, there's no point in subtracting by just one
+            if (args[max_idx] % DIM != 0) {
+                args[max_idx] = (args[max_idx] / DIM) * DIM;
+            } else {
+                args[max_idx] -= DIM;
+            }
+            args[max_idx] = args[max_idx] == 0 ? 1 : args[max_idx];
+        } else {
+            args[max_idx]--;
+        }
 
-    int args[] = {batch_size, pool_out_dim, pool_out_dim, out_channels, in_channels};
-
-    int acc_rows = tiled_conv_total_spad_rows(true, false,
-        stride, args[0], args[1], args[2], args[3], kernel_dim, kernel_dim, args[4], pool_size, pool_stride);
-
-    int och_floor = (args[3]/DIM) + 1;
-    int kch_floor = (args[4]/DIM) + 1;
-
-    int spad_rows_weight = tiled_conv_total_spad_rows(false, true,
-        stride, args[0], args[1], args[2], args[3], kernel_dim, kernel_dim, args[4], pool_size, pool_stride);
-    while(spad_rows_weight > weight_bank * BANK_ROWS){ //tile weight first (allocate bank3 to weight)
-		if(kch_floor > och_floor){
-			kch_floor--;
-			args[4] = kch_floor * DIM;
-		}else{
-			och_floor--;
-			args[3] = och_floor * DIM;
-		}
-		spad_rows_weight = tiled_conv_total_spad_rows(false, true,
-        	stride, args[0], args[1], args[2], args[3], kernel_dim, kernel_dim, args[4], pool_size, pool_stride);
-	}
-
-
-       while(acc_rows > ACC_ROWS){ //batch output channel, output dimension affects
-	   if(args[1] <= 7){
-		if(args[0] > 1){
-			args[0]--;
-		}
-		else{
-			och_floor--;
-			args[3] = och_floor*DIM;
-		}
-	   }
-	   else{
-
-		int max_val = -1;
-		int max_idx = -1;
-		if(args[0]*2 < args[1]){
-			args[1]--;
-			args[2]--;
-		}
-		else args[0]--;
-	   }
-	acc_rows = tiled_conv_total_spad_rows(true, false, stride, args[0], args[1], args[2], args[3], kernel_dim, kernel_dim, args[4], pool_size, pool_stride);
-    }
-//	printf("batch: %d, out_dim: %d, out_channel: %d, in_channel: %d \n", args[0], args[1], args[3], args[4]);
-    int spad_rows_input = tiled_conv_total_spad_rows(false, false,
-        stride, args[0], args[1], args[2], args[3], kernel_dim, kernel_dim, args[4], pool_size, pool_stride);
- //   printf("batch: %d, out_dim: %d, out_channel: %d, in_channel: %d \n", args[0], args[1], args[3], args[4]);
-
-
-    while(spad_rows_input > BANK_ROWS*(BANK_NUM-weight_bank)){// tile input last
-	//batch, input dimension, input channel
-		int max_val = -1;
-		int max_idx = -1;
-		for(int i = 0; i < 5; i++){
-			if(args[i] > max_val && i != 3){
-				if(i!=4){
-					max_val = args[i];
-					max_idx = i;
-				}else if(kch_floor > 1){
-					max_val = args[4];
-					max_idx = 4;
-				}
-			}
-		}
-		if(max_idx == 4){
-			kch_floor = kch_floor -1;
-			args[4] = kch_floor * DIM;
-		}
-		else  args[max_idx]--;
-
-		spad_rows_input = tiled_conv_total_spad_rows(false, false, stride, args[0], args[1], args[2], args[3], kernel_dim, kernel_dim, args[4], pool_size, pool_stride);
+        spad_rows = tiled_conv_total_spad_rows(false,
+            stride, 1, 1, false, false, false,
+            args[0], args[1], args[2], args[3], args[4], args[5], args[6], pool_size, pool_stride);
+        acc_rows = tiled_conv_total_spad_rows(true,
+            stride, 1, 1, false, false, false,
+            args[0], args[1], args[2], args[3], args[4], args[5], args[6], pool_size, pool_stride);
     }
 
+    // Check if we can increase ocols
+    bool not_increased = false;
+    while (!not_increased) {
+        not_increased = true;
 
-    int batches = args[0];
-    int orows = args[1];
-    int ocols = args[2];
-    int ochs = args[3];
-    int kchs = args[4];
-
-
-    /*
-    printf("batches = %d\n", batches);
-    printf("orows = %d\n", orows);
-    printf("ocols = %d\n", ocols);
-    printf("ochs = %d\n", ochs);
-    printf("kcols = %d\n", kernel_dim);
-    printf("kchs = %d\n", kchs);
-    */
-
-    tiled_conv_original(
-        batch_size, in_dim, in_channels,
-        out_channels, out_dim,
-        stride, padding, kernel_dim,
-
-        batches,
-        orows, ocols, ochs,
-	kernel_dim, kchs,
-
-        input,
-        weights,
-        bias,
-        output,
-
-        act, scale, relu6_shift,
-        no_1d ? 0 : pool_size, no_pool ? 0 : pool_stride, pool_padding,
-
-	tiled_conv_type, weight_bank);
-	gemmini_fence();
-}
-
-
-//tiling function for deeper layers (when C is large)
-static void tiled_conv_auto_largeC(
-        int batch_size, int in_dim, int in_channels,
-        int out_channels, int out_dim,
-        int stride, int padding, int kernel_dim,
-
-        elem_t * input,
-        elem_t * weights,
-        acc_t * bias,
-        elem_t * output,
+        int args_candidate[] = {args[0], args[1], args[2], args[3], args[4], args[5], args[6]};
+        args_candidate[ocols_idx]++;
 
-        int act, acc_scale_t scale, size_t relu6_shift,
-        int pool_size, int pool_stride, int pool_padding,
+        if (args_candidate[ocols_idx] > max_args[ocols_idx])
+            continue;
 
-        enum tiled_matmul_type_t tiled_conv_type) {
+        spad_rows = tiled_conv_total_spad_rows(false,
+            stride, 1, 1, false, false, false,
+            args_candidate[0], args_candidate[1], args_candidate[2], args_candidate[3], args_candidate[4], args_candidate[5], args_candidate[6], pool_size, pool_stride);
+        acc_rows = tiled_conv_total_spad_rows(true,
+            stride, 1, 1, false, false, false,
+            args_candidate[0], args_candidate[1], args_candidate[2], args_candidate[3], args_candidate[4], args_candidate[5], args_candidate[6], pool_size, pool_stride);
 
-    const bool no_pool = pool_stride == 0;
-    if (no_pool) {
-        pool_size = 1;
-        pool_stride = 1;
-        pool_padding = 0;
+        if (spad_rows <= max_spad_rows && acc_rows <= max_acc_rows) {
+            args[ocols_idx] = args_candidate[ocols_idx];
+            not_increased = false;
+        }
     }
-    const int weight_bank = 2; //hard-coded number of weight banks to use
 
-    const int pool_out_dim = (out_dim + 2*pool_padding - pool_size) / pool_stride + 1;
-
-    // int args[] = {batch_size, porows, pocols, pochs, krows, kcols, kchs};
-    int args[] = {batch_size, pool_out_dim, pool_out_dim, out_channels, in_channels};
-
-    int acc_rows = tiled_conv_total_spad_rows(true, false,
-        stride, args[0], args[1], args[2], args[3], kernel_dim, kernel_dim, args[4], pool_size, pool_stride);
-//   printf("batch: %d, out_dim: %d, out_channel: %d, in_channel: %d \n", args[0], args[1], args[3], args[4]);
-
-
-    int och_floor = (args[3]/DIM) + 1;
-    int kch_floor = (args[4]/DIM) + 1;
+    // Check if there are any parameters that we can currently still increase
+    bool nothing_increased = false;
+    while (!nothing_increased) {
+        nothing_increased = true;
 
- int spad_rows_weight = tiled_conv_total_spad_rows(false, true,
-        stride, args[0], args[1], args[2], args[3], kernel_dim, kernel_dim, args[4], pool_size, pool_stride);
-    while(spad_rows_weight > weight_bank * BANK_ROWS){ //tile weight first (allocate bank3 to weight)
-	//input channel, output channel
-	och_floor--;
-	args[3] = och_floor * DIM;
-	spad_rows_weight = tiled_conv_total_spad_rows(false, true,
-       	stride, args[0], args[1], args[2], args[3], kernel_dim, kernel_dim, args[4], pool_size, pool_stride);
-    }
+        for (size_t i = 0; i < sizeof(args)/sizeof(args[0]); i++) {
+            int args_candidate[] = {args[0], args[1], args[2], args[3], args[4], args[5], args[6]};
+            args_candidate[i]++;
 
+            if (args_candidate[i] > max_args[i])
+                continue;
 
-       while(acc_rows > ACC_ROWS){ //batch output channel, output dimension affects
-		int max_val = -1;
-		int max_idx = -1;
-		for(int i = 0; i < 3; i++){
-			if(args[i] > max_val){
-				max_val = args[i];
-				max_idx = i;
-			}
-		}
+            spad_rows = tiled_conv_total_spad_rows(false,
+                stride, 1, 1, false, false, false,
+                args_candidate[0], args_candidate[1], args_candidate[2], args_candidate[3], args_candidate[4], args_candidate[5], args_candidate[6], pool_size, pool_stride);
+            acc_rows = tiled_conv_total_spad_rows(true,
+                stride, 1, 1, false, false, false,
+                args_candidate[0], args_candidate[1], args_candidate[2], args_candidate[3], args_candidate[4], args_candidate[5], args_candidate[6], pool_size, pool_stride);
 
-		args[max_idx]--;
-	acc_rows = tiled_conv_total_spad_rows(true, false, stride, args[0], args[1], args[2], args[3], kernel_dim, kernel_dim, args[4], pool_size, pool_stride);
-    }
-//	printf("batch: %d, out_dim: %d, out_channel: %d, in_channel: %d \n", args[0], args[1], args[3], args[4]);
-    int spad_rows_input = tiled_conv_total_spad_rows(false, false,
-        stride, args[0], args[1], args[2], args[3], kernel_dim, kernel_dim, args[4], pool_size, pool_stride);
-
-    while(spad_rows_input > BANK_ROWS*(BANK_NUM-weight_bank)){// tile input last
-	//batch, input dimension
-		int max_val = -1;
-		int max_idx = -1;
-		for(int i = 0; i < 3; i++){
-			if(args[i] > max_val){
-				max_val = args[i];
-				max_idx = i;
-			}
-		}
-		args[max_idx]--;
-
-	spad_rows_input = tiled_conv_total_spad_rows(false, false, stride, args[0], args[1], args[2], args[3], kernel_dim, kernel_dim, args[4], pool_size, pool_stride);
+            if (spad_rows <= max_spad_rows && acc_rows <= max_acc_rows) {
+                args[i] = args_candidate[i];
+                nothing_increased = false;
+            }
+        }
     }
 
-    int batches = args[0];
-    int orows = args[1];
-    int ocols = args[2];
-    int ochs = args[3];
-    int kchs = args[4];
-    int krows = kernel_dim;
-    int kcols = kernel_dim;
-/*
-     printf("batches = %d\n", batches);
-     printf("orows = %d\n", orows);
-     printf("ocols = %d\n", ocols);
-     printf("ochs = %d\n", ochs);
-     printf("kcols = %d\n", kernel_dim);
-     printf("kchs = %d\n", kchs);
-*/
-
-
-    tiled_conv(
-        batch_size, in_dim, in_channels,
-        out_channels, out_dim,
-        stride, padding, kernel_dim,
-
-        batches,
-        orows, ocols, ochs,
-        krows, kcols, kchs,
-
-        input,
-        weights,
-        bias,
-        output,
-
-        act, scale, relu6_shift,
-        pool_size, no_pool ? 0 : pool_stride, pool_padding,
-        weight_bank, tiled_conv_type);
-}
-
-static void tiled_conv_auto(
-        int batch_size, int in_dim, int in_channels,
-        int out_channels, int out_dim,
-        int stride, int padding, int kernel_dim,
-
-        const elem_t * input,
-        const elem_t * weights,
-        const acc_t * bias,
-        elem_t * output,
-
-        int act, acc_scale_t scale, size_t relu6_shift,
-        int pool_size, int pool_stride, int pool_padding,
+    const int batches = args[0];
+    const int orows = args[1];
+    const int ocols = args[2];
+    const int ochs = args[3];
+    const int krows = args[4];
+    const int kcols = args[5];
+    const int kchs = args[6];
 
-        enum tiled_matmul_type_t tiled_conv_type) {
+    /*
+    spad_rows = tiled_conv_total_spad_rows(false,
+        stride, 1, 1, false, false, false,
+        args[0], args[1], args[2], args[3], args[4], args[5], args[6], pool_size, pool_stride);
+    acc_rows = tiled_conv_total_spad_rows(true,
+        stride, 1, 1, false, false, false,
+        args[0], args[1], args[2], args[3], args[4], args[5], args[6], pool_size, pool_stride);
 
-    const bool no_pool = pool_stride == 0;
-    if (no_pool) {
-        pool_size = 1;
-        pool_stride = 1;
-        pool_padding = 0;
-    }
+    printf("batches = %d\n", batches);
+    printf("orows   = %d\n", orows);
+    printf("ocols   = %d\n", ocols);
+    printf("ochs    = %d\n", ochs);
+    printf("krows   = %d\n", krows);
+    printf("kcols   = %d\n", kcols);
+    printf("kchs    = %d\n\n", kchs);
 
-    const int pool_out_dim = (out_dim + 2*pool_padding - pool_size) / pool_stride + 1;
-    const int weight_bank = 1;
-    int args[] = {batch_size, pool_out_dim, pool_out_dim, out_channels, in_channels};
-
-    int och_floor = (args[3]/DIM) + 1;
-
-    int spad_rows_weight = tiled_conv_total_spad_rows(false, true,
-        stride, args[0], args[1], args[2], args[3], kernel_dim, kernel_dim, args[4], pool_size, pool_stride);
-    while(spad_rows_weight > BANK_ROWS * weight_bank){ //tile weight first (allocate bank3 to weight)
-	//input channel, output channel
-	och_floor = och_floor -	1;
-	args[3] = och_floor * DIM;
-	spad_rows_weight = tiled_conv_total_spad_rows(false, true,
-        	stride, args[0], args[1], args[2], args[3], kernel_dim, kernel_dim, args[4], pool_size, pool_stride);
-    }
+    printf("total spad_rows reserved: %d\n", spad_rows);
+    printf("total acc_rows reserved: %d\n\n", acc_rows);
 
-    int acc_rows = tiled_conv_total_spad_rows(true, false,
-		stride, args[0], args[1], args[2], args[3], kernel_dim, kernel_dim, args[4], pool_size, pool_stride);
+    printf("scratchpad row utilization: %d%%\n", (spad_rows*100) / max_spad_rows);
+    printf("accumulator row utilization: %d%%\n\n", (acc_rows*100) / max_acc_rows);
 
-    while(acc_rows > ACC_ROWS){ //batch output channel, output dimension affects
- //tile output dimension
-	args[1]--;
-	args[2]--;
+    printf("inner matmul size: i=%d, j=%d, k=%d\n\n", ocols, ochs, kchs);
+    */
 
-	acc_rows = tiled_conv_total_spad_rows(true, false, stride, args[0], args[1], args[2], args[3], kernel_dim, kernel_dim, args[4], pool_size, pool_stride);
-    }
-//	printf("batch: %d, out_dim: %d, out_channel: %d, in_channel: %d \n", args[0], args[1], args[3], args[4]);
-
-    int batches = args[0];
-    int orows = args[1];
-    int ocols = args[2];
-    int ochs = args[3];
-    int krows = kernel_dim;//args[4];
-    int kcols = kernel_dim;//args[5];
-    int kchs = args[4];
-
-/*
-     printf("batches = %d\n", batches);
-     printf("orows = %d\n", orows);
-     printf("ocols = %d\n", ocols);
-     printf("ochs = %d\n", ochs);
-     printf("kcols = %d\n", kernel_dim);
-     printf("kchs = %d\n", kchs);
-*/
-    tiled_conv(
-        batch_size, in_dim, in_channels,
-        out_channels, out_dim,
+    tiled_conv_dw(
+        batch_size, in_dim, channels, out_dim,
         stride, padding, kernel_dim,
 
         batches,
         orows, ocols, ochs,
-        krows, kcols, kchs,
+        krows, kcols,
 
         input,
         weights,
@@ -4671,9 +2977,10 @@ static void tiled_conv_auto(
         act, scale, relu6_shift,
         pool_size, no_pool ? 0 : pool_stride, pool_padding,
 
-        weight_bank, tiled_conv_type);
+        tiled_conv_type);
 }
 
+
 static void resadd_cpu(const size_t I, const size_t J,
         const scale_t A_scale,
         const scale_t B_scale,
@@ -4701,6 +3008,7 @@ static void resadd_cpu(const size_t I, const size_t J,
     }
 }
 
+
 static void sp_tiled_resadd(const size_t I, const size_t J,
         const scale_t A_scale,
         const scale_t B_scale,
@@ -4771,8 +3079,8 @@ static void tiled_resadd(const size_t I, const size_t J,
         bool relu,
         enum tiled_matmul_type_t matadd_type) {
 
-    gemmini_config_st(J * sizeof(elem_t));
-    gemmini_config_ex(WS, relu ? RELU : NO_ACTIVATION, 0, C_scale, 0);
+    gemmini_extended_config_st(J * sizeof(elem_t), relu ? RELU : NO_ACTIVATION, C_scale);
+    gemmini_config_ex(WS, 0, 0, 0);
 
     gemmini_extended4_config_ld(J * sizeof(elem_t), A_scale, true, DIM, 0);
     gemmini_extended4_config_ld(J * sizeof(elem_t), B_scale, true, DIM, 1);
@@ -4846,6 +3154,7 @@ static void tiled_resadd_auto(const size_t I, const size_t J,
     }
 }
 
+
 static void global_average_cpu(const elem_t * input, elem_t * output,
     int batches, int channels, int dim) {
   const int count = dim * dim;
@@ -4861,11 +3170,16 @@ static void global_average_cpu(const elem_t * input, elem_t * output,
         }
       }
 
+#ifdef ELEM_T_IS_FLOAT
+      output[batch * channels + channel] = sum / count;
+#else
       output[batch * channels + channel] = (sum + count/2) / count;
+#endif
     }
   }
 }
 
+
 static void sp_tiled_global_average(const elem_t * input, elem_t * output,
     int batches, int channels, int dim, int channel_tile_size) {
   const uint32_t C_acc_addr_start = ((uint32_t)1 << 31);
@@ -4909,13 +3223,14 @@ static void sp_tiled_global_average(const elem_t * input, elem_t * output,
   }
 }
 
+
 static void tiled_global_average(const elem_t * input, elem_t * output,
     int batches, int channels, int dim,
     int channel_tile_size) {
 
   gemmini_extended4_config_ld(DIM*sizeof(elem_t), MVIN_SCALE_IDENTITY, true, 1, 0);
-  gemmini_config_ex(0, NO_ACTIVATION, 0, 1.0 / (dim*dim), 0);
-  gemmini_config_st(0);
+  gemmini_config_ex(0, NO_ACTIVATION, 0, 0);
+  gemmini_extended_config_st(0, NO_ACTIVATION, 1.0 / (dim*dim));
 
   for (int batch = 0; batch < batches; batch++) {
     for (int channel = 0; channel < channels; channel += channel_tile_size) {
@@ -4929,6 +3244,7 @@ static void tiled_global_average(const elem_t * input, elem_t * output,
   }
 }
 
+
 static void tiled_global_average_auto(const elem_t * input, elem_t * output,
     int batches, int channels, int dim,
     enum tiled_matmul_type_t type) {
